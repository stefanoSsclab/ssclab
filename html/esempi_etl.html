<!DOCTYPE html>
<html>
<head>
	<meta charset="ISO-8859-1">
	<meta name="description" content="Esempi programmazione lineare">
	<meta name="keywords" content="Esempi Simplesso, Simplex Examples">
	<title>Esempi Java API simplesso</title>
	<script type="text/javascript" src="sintax/scripts/shCore.js"></script>
	<script type="text/javascript" src="sintax/scripts/shBrushJava.js"></script>
	<link type="text/css" rel="stylesheet"	href="sintax/styles/shCoreDefault.css" />
	<script type="text/javascript">
		SyntaxHighlighter.all();
	</script>
	<link rel="stylesheet" type="text/css" href="css/structure.css" media="screen">
</head>
<body>
	<div id="principale">
		<div id="div_p_left">&nbsp;</div>
		<div id="div_p_right">&nbsp;</div>
		<div id="div_p_center">
			<div id="div_menu">
				<div id="div_menu_img">
					<a title="Home" href="index.html"><img alt="Home" src="images/java_ssc_2.gif"></a>
				</div>
				<div id="div_menu_ul">
					<ul class="menu">
						<li><a title="Esempi programmazione lineare" href="esempi.html">Esempi</a></li>
						<li><a title="Documentazione API" href="api/index.html" target="_new">Api</a></li>
						<li><a title="Download SSC" href="download.html">Download</a></li>
						<li><a title="Informazioni" href="info.html">Info</a></li>
						<li><a title="Privacy Policy" href="privacy.html">P.P.</a></li>
					</ul>
				</div>
			</div>

			<h3 class="paragraph_title"><a id="home_indice">ETL - Indice degli esempi</a></h3>
			<div class="indice_esempi">
				<ol>
					<li>Funzionalit&agrave; di base 
						<ol>

							<li><a href="#ese1_1">Lettura di dati da una stringa di testo e creazione di una tabella nativa</a></li>
							<li><a href="#ese1_2">Lettura di dati da un file di testo e creazione di un tabella nativa</a></li>
							<li><a href="#ese1_3">Lettura di una tabella nativa  ed esportazione dei dati in un file di testo</a></li>
						

						</ol>
					</li>

					<li>Accesso ad un database 
						<ol>

							<li><a href="#ese2_1">Risoluzione di un problema di MILP in
									 formato naturale</a></li>
						

						</ol>
					</li>
				</ol>
			</div>












			<h3 class="paragraph_title">
				<a id="ese1_1">Esempio 1.1</a>
			</h3>

			<div class="commento">
				Nel codice sottostante viene riportato un esempio di caricamento dati da una stringa di testo costituita da pi&ugrave; righi 
				(ogni rigo corrisponde ad un record). Per semplicit&agrave; si &egrave; utilizzata una stringa per contenere le informazioni, ma queste possono essere  
				contenute in file o in altri tipi di input. <br><br> 
				
				
				Preliminarmente occorre creare una sessione di lavoro [rigo 14] che 
				rappresenta l'ambiente nel quale SSC viene eseguito.  
				La lettura  delle informazioni presenti nei 5 record [righi 18-22] si effettuata definendo un tracciato record 
				(denominato anche formato di input) con il quale si descrive come va letto ed interpretato il contenuto presente 
				nei record. La definizione del tracciato record avviene definendo una stringa da passare come argomento al metodo setInputFormat() 
				[rigo 25]. In questa stringa si susseguono le notazioni "nome variabile : tipologia variabile" per definire, in sequenza, 
				il nome ed il tipo di dato in cui memorizzare le informazioni presenti nei record <br><br>
				
				Le tipologie di dati esistenti in SSC sono elencate nella pagina <A href="">Tipo di dato in SSC</a>. Nel tracciato record dell'esempio 
				sottostante definiano due variabili di tipo stringa con una lunghezza massima di 10 caratteri (variabili NOME e COGNOME), una variabile di tipo 
				data con formato di lettura espresso nella notazione gg/mm/aaaa (variabile NASCITA), una variabile booleana (CELIBE) che pu&ograve; 
				assumere solo i valori F (false) o T (true), la variabile di tipo numerico  ALTEZZA ed infine una variabile SESSO 
				costituita da un solo carattere. <br><br>
				
				Per poter memorizzare permanentemente i dati letti in una tabella nativa SSC, occorre definire una libreria in cui poter memorizzare la tabella. 
				Una libreria &egrave; rappresentata da  un nome logico che corrisponde ad una locazione fisica 
				(file system o DB) nella quale le tabelle vengono memorizzate. Nel nostro caso creiamo una libreria con il nome logico 
				"PERSONE" a cui corrisponde la directory "e:/dati_ssc" [rigo 27]. Il nome logico "PERSONE", assegnato alla libreria, 
				vale solo per la durata delle sessione SSC corrente; se in un altro contesto allochiamo la stessa directory fisica con un nome logico 
				differente (ad esempio "STUDENTI"), avremo sempre accesso alle tabelle che contiene. <br><br>
				
				La creazione di una tabella nativa avviene creando e facendo eseguire una istanza della classe DataStep [righi 29-30]. Il metodo 
				session.createDataStep() accetta come parametri due argomenti, il primo &egrave; una stringa contenente (con una notazione a due livelli LIBRERIA.NOME_TABELLA) 
				la libreria ed il nome della tabella da creare , il secondo argomento &egrave; un oggetto che &egrave; un riferimento ai dati di input. 
				Fatto eseguire il datastep verr&agrave;  creata nella libreria PERSONE la tabella DIPLOMATI contenente tutti i campi  definiti nel formato di input. 
				All'interno della directory  "e:/dati_ssc" verranno generati dei file che costituiranno la tabella  creata. <br><br>
				
				Infine al rigo 34 viene chiusa la sessione SSC in modo da eliminare file temporanei e la relativa area di work. 
				
				
			
				
			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">

import it.ssc.context.Context;
import it.ssc.context.Session;
import it.ssc.library.LibraryInterface;
import it.ssc.log.SscLogger;
import it.ssc.process.DataStep;
import it.ssc.ref.InputString;

public class Example {
	
	public static void main(String[] args) throws Exception {
		
		Session session = null;
		try {
			session  = Context.createNewSession();			
			
			String dati=
			
						"Atefanin Variol  07-01-1968 f 1.78 M \n"  +
						"Giuseppe Fernano 17-05-1971 t 1.64 M \n"  +
						"Badiac Comaneci   03-11-1943 f 1.64 F\n"  +
						"Stefano Scarioli  07-01-1968 f 1.78 M\n"  +
						"Giuseppe Serranda 17-05-1971 t 1.64 M";  
			
			InputString input = new InputString(dati); 
			input.setInputFormat("NOME:varstring(10), COGNOME:varstring(10), NASCITA:date(gg/mm/aaaa), CELIBE:boolean, ALTEZZA:float, SESSO:singlechar");
			
			LibraryInterface libreria= session.addLibrary("PERSONE", "e:/dati_ssc");	
			
			DataStep data_step = session.createDataStep("PERSONE.DIPLOMATI", input);  
			data_step.execute();
				
		} 
		finally {
			 session.close();
		}
	}
}				

				</pre>
							

			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>














































			<h3 class="paragraph_title">
				<a id="ese1_2">Esempio 1.2</a>
			</h3>

			<div class="commento">
				Nell'esempio precedente abbiamo visto come importare dati da una stringa. In questo esempio carichiamo  i dati da un file 
				di testo chiamato candidati.txt. Il contenuto del file candidati.txt &egrave; dato da : 
				<pre>

			
00045SSRSFN78A09A952NGENZANO DI LUCANIA                        RM
VIA OCEANO INDIANO                                             36 
09-01-1978    6              F                                 53000
da saltare
da saltare
00072TRFSFN68A07D456BARICCIA                                   RM
VIA FRATELLI ZANZARA                                           4 
07-11-1968    4              M                                 54000
da saltare
da saltare
00128SFHFRH53B03A572LROMA                                      RM
VIA OCEANO ATLANTICO                                           55 
03-12-1953    7              F                                 68000
da saltare
da saltare

        10        20        30        40        50        60 				
---------|---------|---------|---------|---------|---------|--------

				</pre>
A differenza dell'esempio precedente nel quale il formato di input era a formato libero, in questo esempio si
deve utilizzare anche quello a colonna in quanto vi sono informazioni che non sono separate da spazi. Pi&ugrave; in generale, in 
SSC il formato di input &egrave di tre tipi : <br><br>

A) Libero: nel formato libero le informazioni presenti in un record sono divise da un separatore che di default risulta essere uno o pi&ugrave; spazi. 
Il pattern di separazione delle informazioni, rappresentato come espressione regolare, &egrave; uguale a "\\s+". 
Per dichiarare un  formato di input libero [rigo 25 dell'esempio precedente] basta elencare in successione il nome 
della variabile ed il suo tipo, senza specificare nessuna indicazione sulla posizione dai valori da acquisire. 
Se le informazioni da acquisire sono separate da un diverso separatore o pattern, basta specificare 
un nuovo separatore con il metodo setSeparator() degli oggetti Input<br><br>

B) A colonna : nel formato a colonna si deve specificare, tra parentesi quadre, la posizione di inizio e  fine dell'informazione. Ad esempio 
dichiarare nel formato di input una variabile con la notazione CITTA:varstring(70)[22-63] , significa dichiarare una variabile di nome CITTA 
di tipo stringa la cui lunghezza massima &egrave; di 70 caratteri e che  memorizza tutto ci&ograve; che &egrave; compreso tra il 22-esimo ed il 63-esimo 
carattere (colonna) di ogni rigo letto. <br><br>

C) Misto: nel formato misto si pu&ograve; contemporaneamente utilizzare sia la notazione libera che quella a colonna. <br><br>

Nell'esempio sottostante si utilizza il formato misto. Inoltre i dati riportati nel file 
candidati.txt hanno anche la particolarit&agrave; che le informazioni riguardanti una singola unit&agrave; statistica sono 
presenti su pi&ugrave; righe (5 righe di cui le due finali sono da saltare). <br><br>


Se nell'esempio precedente, per leggere le informazioni presenti un una stringa, avevamo utilizzato un oggetto della classe InputString, 
ora per leggere le informazioni presenti in un file utilizzeremo la classe InputFile. Il costruttore  della classe  InputFile
richiede come argomento il path del file da leggere [rigo 14]. Con la riga successiva si dichiara il formato di input. 
La prima informazione da leggere &egrave; il cap contenuto nelle prime 5 colonne; con la notazione CAP:varstring(5)[1-5], 
si dichiara una variabile di tipo stringa di nome CAP con una lunghezza massima di 5 caratteri e che acquisisce tutte  
le informazioni contenute tra la colonna 1 e la colonna 5. Con la notazione successiva (CF:varstring(16)[6-21]) si dichiara 
una variabile CF di tipo stringa di lunghezza 16 che memorizza tutto ci&ograve; che &egrave; contenuto tra la colonna 6 e 21.
Segue la dichiarazione della variabile CITTA che pu&ograve;
contenere anche la stringa "GENZANO DI LUCANIA", informazione che &egrave; costituita da pi&ugrave; parole separate da spazi, ma avendo usato  
 il formato a colonne possiamo importarlo per intero. Per leggere le informazioni sulla provincia e memorizzarle nella variabile PROV, basta
una dichiarazione con il formato libero, in quanto il cursore, in seguito alla precedente lettura del campo CITTA, si &egrave; 
posizionato sulla colonna 64, quindi per leggere i restanti 2 caratteri basta una dichiarazione nel formato libero ( PROV:varstring(2) ).

<br><br>
In teoria tutte le informazioni presenti sul primo rigo sono state mappate, per&ograve; se si 
 vuole dichiarare una variabile che legga  delle sotto informazioni presenti a monte del cursore, questo &egrave; possibile. Con la notazione  
ANNO:varstring(2)[12-13], si specifica al cursore, dopo aver letto il campo relativo alla provincia, di riposizionarsi sulla
colonna 12 e leggere il contenuto che va dalla colonne 12 alla 13 e memorizarlo in una variabile ANNO di tipo stringa di lunghezza 2. 
<br><br>
Le informazioni presenti sulla prima riga del file sono state mappate, ma altre sono ancora presenti sulle righe successive 
che fanno parte della stessa unit&agrave; statistica. Per poter memorizzare informazioni 
presenti su una nuova riga, ma relative alla stessa unit&agrave; statistica, si utilizza il sinbolo @@. Con @@ si dichiara che 
le informazioni relative ad una stessa osservazione non sono terminate con la riga , ma continuano sulla riga successiva. 
Dichiarato il simbolo @@ ci si posiziona all'inizio del rigo successivo e si possono leggere le informazioni sulla via (VIA:varstring(64)[1-63]) ed il numero civico 
(CIVICO:varstring(2)). Ora siccome le informazioni relative alla stessa osservazione continuano anche sulla riga successiva 
si ripete ancora il simbolo @@ per leggere la data di nascita presente sul terzo rigo (DATA_NASCITA:date(gg-mm-aaaa)). 

<br><br>Effettuata la lettura della data di nascita si vuole memorizzare il reddito presente dalla colonna 64 in poi del terzo rigo. 
Per memorizzare questa informazione e saltare il contenuto precedente che non interessa, si pu&ograve; utilizzare la notazione a colonna, 
oppure saltare semplicemente in contenuto con l'istruzione @n (nell'esempio @64). Con questa istruzione il cursore passa dalla colonna 11 
(posizione assunta dopo la lettura della data di nascita) alla colonna 64. Da tale posizione si pu&ograve memorizzare il reddito 
(reddito:int) in una variabile intera. Infine occorre saltare le due successive righe, ci&ograve; si effettua con l'istruzione #2. 
L'istruzione #n fa saltare gli n righi successivi. 
La dichiarazione del formato di input termina, ma essendo ancora presenti nel file di input record da leggere, durante l'esecuzione del DataStep [riga 21]
si ripete il procedimento di memorizzazione di una nuove unit&agrave; statistiche fino al raggiungimento della fine del file. 
Alle termine della lettura del file avremo memorizzato tre unit&agrave; 
statistiche che verranno memorizzate nella tabella CANDIDATI .

				    
			
			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">

import it.ssc.context.Context;
import it.ssc.context.Session;
import it.ssc.process.DataStep;
import it.ssc.process.FactorySteps;
import it.ssc.ref.InputFile;

public class Esempio {

	public static void main(String[] args) throws Exception {
		
		Session session =  Context.createNewSession();
		try {
			
			InputFile file_input = new InputFile("E:/file_ssc/ssc_txt/candidati.txt");
			file_input.setInputFormat(
			"CAP:varstring(5)[1-5], CF:varstring(16)[6-21], CITTA:varstring(70)[22-63], PROV:varstring(2), ANNO:varstring(2)[12-13] , @@, VIA:varstring(64)[1-63], CIVICO:varstring(2), @@, DATA_NASCITA:date(gg-mm-aaaa), @64, reddito:int,#2");
		
			session.addLibrary("PERSONE", "E:\\dati_ssc");
		
			DataStep data_step = session.createDataStep("PERSONE.CANDIDATI", file_input); 
			data_step.execute();
			
		} 
		finally {
			session.close();
		}
	}
}
	

				</pre>
						
			</div>
			<div class="commento">
			<br>
			<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
			</div>



















































			<h3 class="paragraph_title">
				<a id="ese1_3">Esempio 1.3</a>
			</h3>

			<div class="commento">
			In questo esempio vogliamo leggere i dati presenti nella tabella nativa SSC generata nell'esempio precedente 
			per generare un file in formato testo fomattato. Per poter fare questa operazione occorre creare una sessione di lavoro SSC, 
			allocare la libreria dove &egrave; contenuta la tabella ed ottenere un riferimento di tipo Input alla tabella "CANDIDATI". 
			Ricordiamo che in SSC i nomi delle tabelle sono case sensitive. Dichiararle in minuscolo o maiuscolo significa nominare due 
			tabelle distinte. <br><br>
			
			Se per la creazione di una tabella occorreva creare un oggetto DataStep, per creare un file alimentato da un input, 
			occorre creare il corrispettivo oggetto per i file chiamato FileStep. Il metodo createFileStep() dell'oggetto session accetta come 
			parametri due argomenti, il primo &egrave; il nome del file dove verranno salvate le informazioni, il secondo rappresenta l'input 
			(in questo caso una tabella nativa) dal quale verranno prelevate le informazioni. <br><br>
			
			La tabella nativa CANDIDATI, presenta le seguenti colonne o campi o variabili : CAP, CF, CITTA, PROV, SUB_CF, VIA, CIVICO, DATA_NASCITA, 
			REDDITO. Nel file di testo noi vogliamo solo trascivere i campi CITTA, PROV, CF, DATA_NASCITA opportunamente formattati. Per far cio occorre 
			definitìre il formato di output come primo argomento del metodo printf e come argomenti successivi i nomi dei campi della tabella che si vogliono 
			trascrivere nel file di output. La sintassi per la formattazione &egrave; la stessa della classe <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html">java.util.Formatter</a>. 
			In questo caso il campo CITTA viene salvato come stringa con una lunghezza massima di 8 caratteri (%.8s), il campo PROV anch'esso come 
			stringa con una lunghezza minima di 5 catatteri (%5s), il campo CF come una stringa in maiuscolo avente una lunghezza minima di 13 
			caratteri (%13S) ed infine il campo  NASCITA con il formato mese/giorno/anno (%tD). La sintassi completa per la formattazione degli output 
			di testo pu&ograve; essere visionata a questo <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html">link </a>
			

				
			
			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">
				
import it.ssc.context.Context;
import it.ssc.context.Session;
import it.ssc.library.LibraryInterface;
import it.ssc.process.FileStep;
import it.ssc.ref.Input;

public class Esempio {
	
public static void main(String[] args) throws Exception {
		
		Session session = Context.createNewSession();
		try {
			
			LibraryInterface library=session.addLibrary("PERSONE", "E:\\dati_ssc");
			Input candidati=library.getInput("CANDIDATI");
			
			FileStep file_step = session.createFileStep("E:/file_ssc/salva_candidati.txt", candidati); 
			file_step.printf("%.8s %5s  %13S %tD", "CITTA", "PROV", "CF", "DATA_NASCITA");
			file_step.execute();
			  	
		} 
		finally {
			session.close();
		}
	}
}

				</pre>
							

			</div>
			<div class="commento">
			<br>
			<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
			</div>





		</div>
	</div>
</body>