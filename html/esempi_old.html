<!DOCTYPE html>
<html>
<head>
	<meta charset="ISO-8859-1">
	<meta name="description" content="Esempi programmazione lineare">
	<meta name="keywords" content="Esempi Simplesso, Simplex Examples">
	<title>Esempi Java API simplesso</title>
	<script type="text/javascript" src="sintax/scripts/shCore.js"></script>
	<script type="text/javascript" src="sintax/scripts/shBrushJava.js"></script>
	<link type="text/css" rel="stylesheet"	href="sintax/styles/shCoreDefault.css" /> 
	<script type="text/javascript">
		SyntaxHighlighter.all();
	</script>
	<link rel="stylesheet" type="text/css" href="css/structure.css" media="screen">

</head>
<body>
	<div id="principale">
		<div id="div_p_left">&nbsp;</div>
		<div id="div_p_right">&nbsp;</div>
		<div id="div_p_center">
			<div id="div_menu">
				<div id="div_menu_img">
					<a title="Home" href="index.html"><img alt="Home" src="images/java_ssc_2.gif"></a>
				</div>
				<div id="div_menu_ul">
					<ul class="menu">
						<li><a title="Esempi programmazione lineare" href="esempi.html">Esempi</a></li>
						<li><a title="Download SSC" href="download.html">Download</a></li>
						<!--   <li><a title="Documentazione" href="doc.html">Doc</a></li> -->
						<li><a title="Documentazione API" href="api/index.html" target="_new">Api</a></li>
						<li><a title="Informazioni" href="info.html">Info</a></li>
						<li><a title="Privacy Policy" href="privacy.html">P.P.</a></li>
					</ul>
				</div>
			</div>

			<h3 class="paragraph_title"><a id="home_indice">Indice degli esempi </a></h3>
			<div class="indice_esempi">
				<ol>
					<li>Programazione lineare 
						<ol>

							<li><a href="#ese1_1">Risoluzione di un problema di LP
									espresso in formato a coefficienti</a></li>
							<li><a href="#ese1_2">Risoluzione di un problema di LP
									espresso in formato matriciale</a></li>
							<li><a href="#ese1_3">Risoluzione di un problema di LP
									con variabili delimitate e libere espresso in formato
									a coefficienti</a></li>
							<li><a href="#ese1_4">Risoluzione di un problema di LP
									con variabili delimitate e libere espresso in formato
									matriciale</a></li>
							<li><a href="#ese1_5">Risoluzione di un problema di LP
									espresso in formato a disequazioni</a></li>
							<li><a href="#ese1_6">Risoluzione di un problema di LP
									con variabili delimitate e libere 
									espresso in formato a disequazioni</a></li>
							<li><a href="#ese1_7">Risoluzione di un problema di LP
									espresso in formato sparso</a></li>
							<li><a href="#ese1_8">Risoluzione di un problema di LP
									in formato a coefficienti memorizzato in un file di testo</a></li>
							<li><a href="#ese1_9">Risoluzione di un problema di LP 
									in formato sparso memorizzato in un database </a></li>
							<li><a href="#ese1_10">Risoluzione di un problema di LP
									al fine di ottenere solo una soluzione ammissibile</a></li>
							<li><a href="#ese1_11">Risoluzione di un problema di LP
									in formato a disequazioni memorizzato in un file di testo</a></li>
							<li><a href="#ese1_12">Risoluzione di un problema di LP
									in formato sparso memorizzato in un file di testo</a></li>			
							<li><a href="#ese1_13">Risoluzione di un problema di LP
									e modifica della tolleranza &epsilon; relativa al valore assunto 
									dalla f.o. al termine della fase 1 del simplesso</a></li>
							<li><a href="#ese1_14">Risoluzione di un problema di LP
									mediante un'implementazione del simplesso parallelo</a></li>	
							

						</ol>
					</li>

					<li>Programazione lineare intera, misto intera e binaria 
						<ol>

							<li><a href="#ese2_1">Risoluzione di un problema di MILP in
									 formato a coefficienti</a></li>
							<li><a href="#ese2_2">Risoluzione di un problema di MILP in 
									formato matriciale</a></li>
							<li><a href="#ese2_3">Risoluzione di un problema di MILP in 
									formato sparso</a></li>
							<li><a href="#ese2_4">Risoluzione di un problema di MILP in
									 formato a coefficienti con variabili binarie</a></li>
							<li><a href="#ese2_5">Risoluzione di un problema di MILP in
									 formato matriciale con variabili binarie</a></li>
							<li><a href="#ese2_6">Risoluzione di un problema di MILP in
									 formato sparso con variabili binarie</a></li>
							<li><a href="#ese2_7">Risoluzione di un problema di MILP in formato a 
							                      disequazioni</a></li>
							<li><a href="#ese2_8">Risoluzione di un problema di MILP e confronto della soluzione 
							                     ottima con quella ottenuta dal suo rilassamento</a></li>    
							<li><a href="#ese2_9">Risoluzione di un problema di MILP e confronto del valore 
							                      che assume la parte LHS di ogni vincolo 
							                      con il corrispettivo valore RHS .  
				     								</a></li>     
				     		<li><a href="#ese2_10">Risoluzione di un problema di MILP che presenta variabili 
				     		semicontinue.  
				     								</a></li>  
				     		<li><a href="#ese2_11">Risoluzione di un problema di MILP in formato matriciale che presenta variabili 
				     		semicontinue. 
				     								</a></li> 	
				     								
				     								
				     		<li><a href="#ese2_12">Risoluzione di un problema di MILP in formato sparso che presenta variabili 
				     		semicontinue.
				     								</a></li> 		
				     								
				     		<li><a href="#ese2_13">Risoluzione di un problema di MILP utilizzando thread multipli (B&B parallelo).
				     								</a></li> 
				     		<li><a href="#ese2_14">Risoluzione di un problema di MILP
									al fine di ottenere  una soluzione ammissibile</a></li>											               

						</ol>
					</li>
				</ol>
			</div>

















			<h3 class="paragraph_title">
				<a id="ese1_1">Esempio 1.1</a>
			</h3>

			<div class="commento">
				Si consideri il seguente problema di LP: <br> <br>
<pre>
	 max  X<sub>1</sub> +   3X<sub>2</sub>
	 
	      X<sub>1</sub> +    X<sub>2</sub> &#x2265;-1
   	      X<sub>1</sub> + 1.4X<sub>2</sub> &#x2264; 6
   	    -5X<sub>1</sub> +   3X<sub>2</sub> = 5
   	    
   	 con X<sub>1</sub>, X<sub>2</sub> &#x2265; 0
</pre>
				<br> Per risolvere questo problema con SSC basta creare
				del testo dove ciascun rigo rappresenta o la funzione obiettivo o un vincolo, mentre le colonne rappresentano i coefficienti 
				delle variabili, le relazioni, i valori rhs [righi 14-17 del codice sottostante]. Questa rappresentazione  
				&egrave; denominata a coefficienti. <br> <br> 
				
				Formulato il problema  
				occorre specificare  il suo tracciato record (o formato di input). 
				
				Per formato di input intendiamo una dichiarazione che descrive 
				come vanno lette ed interpretate le colonne presenti nel testo in cui si &egrave; formulato il problema
				[righi 14-17].  
				La definizione del formato di input si effettuata attraverso una stringa da passare 
				come argomento al  metodo setInputFormat() [rigo 21]; in questa stringa 
				si susseguono le notazioni "nome colonna : tipologia colonna" per  definire, in sequenza,  
				il nome ed il tipo delle colonne. 
				In definitiva si dichiarano: i nomi delle prime due colonne che rappresentano le variabili del problema di LP 
				(in questo caso X<sub>1</sub> e X<sub>2</sub>, di tipo numerico double), la colonna delle
				relazioni (chiamata TYPE e di tipo stringa), la colonna dei valori rhs 
				(chiamata RHS e di tipo double). 
				I nomi da assegnare alle variabili del problema di LP possono essere qualsiasi, mentre la colonna delle relazioni e quella 
				dei valori rhs devono necessariamente chiamarsi TYPE e RHS [rigo 21].  <br> <br> 
				
				Di norma possiamo chiamare le variabili in qualsiasi modo, anche con nomi non necessariamente seguiti da un numero, ad esempio : 
				"FUEL:double, AMOUNT:double, WEIGHT:double", etc, etc. Di solito per&ograve; &egrave; preferibile 
				dichiarare le n variabili di un problema  con una diversa notazione, chiamata ad intervalli, che risulta  
				particolarmente utile se le variabili del problema sono decine o centinaia. In questo caso la dichiarazione   
				"X1:double, X2:double, X3:double, .... , Xn:double" di n variabili,   
				pu&ograve; essere sostituita con la notazione "X1-Xn:double". Questa seconda notazione,  certamente pi&ugrave; compatta,  
				permette di  dichiarare tutte le variabili comprese nell'intervallo che va da X<sub>1</sub> a X<sub>n</sub>. <br> <br> 
				
				
				Una volta rappresentato il problema
				e assegnati i nomi alle variabili, si esegue l'algoritmo del
				Simplesso mediante la creazione di un oggetto della classe LP e l'invocazione del
				metodo resolve() [righi 23-24]. Una volta eseguito il Simplesso, il
				metodo resolve() ritorna il tipo di soluzione trovata; se la
				soluzione &egrave; ottima &egrave; possibile ricavare i valori delle
				variabili ed il valore ottimo della funzione obiettivo. Si
				ricorda che in SSC, di default, le variabili di un  problema di LP sono
				considerate, se non diversamente specificato, non negative (
				&#x2265; 0).
			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">

import it.ssc.log.SscLogger;
import it.ssc.pl.milp.LP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.ref.InputString;


public class Esempio {
	
	public static void main(String[] args) throws Exception {

		String lp_string = 
			                " 1    3    max      .    \n" +  
			                " 1    1    ge      -1    \n" +	  
			                " 1  1.4    le       6    \n" +  
			                "-5    3    eq       5";
			

		InputString lp_input = new InputString(lp_string); 
		lp_input.setInputFormat("X1:double, X2:double, TYPE:varstring(3), RHS:double"); 

		LP lp = new LP(lp_input); 
		SolutionType solution_type=lp.resolve();
		
		if(solution_type==SolutionType.OPTIMUM) { 
			Solution solution=lp.getSolution();
			for(Variable var:solution.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
		}	
		else SscLogger.log("Soluzione non ottima:"+solution_type);
	}
}
				</pre>
							

			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>


















			<h3 class="paragraph_title">
				<a id="ese1_2">Esempio 1.2</a>
			</h3>
			<div class="commento">
				Si consideri il problema di LP riportato nell'esempio precedente e
				dato da: <br> <br>
				<pre>
	 max  X<sub>1</sub> +   3X<sub>2</sub>
	 
	      X<sub>1</sub> +    X<sub>2</sub> &#x2265;-1
   	      X<sub>1</sub> + 1.4X<sub>2</sub> &#x2264; 6
   	    -5X<sub>1</sub> +   3X<sub>2</sub> = 5
   	    
   	 con X<sub>1</sub>, X<sub>2</sub> &#x2265; 0
</pre>
				<br> Il problema dell'esempio precedente pu&ograve; essere
				espresso anche attraverso l'uso di vettori e matrici.  
				Il formato di rappresentazione utilizzato &egrave; 
				simile a quello di Apache simplex solver. In questo caso
				occorre definire la matrice A dei coefficienti , il vettore c  dei coefficienti
				della f.o. ed il vettore b dei valori RHS.
				<br><br>
				
				Definite tali entit&agrave; [righi 18-23] si crea un oggetto
				LinearObjectiveFunction [rigo 27] che rappresenta la funzione
				obiettivo e gli oggetti Constraint [rigo 31] che rappresentano i
				vincoli. Il tipo di vincolo (LE, GE, EQ) viene specificato attraverso 
				gli elementi dell'array delle relazioni "rel", array contenente oggetti 
				di tipo ConsType [rigo 25].
				Infine, la lista di vincoli e la funzione obiettivo sono parametri
				sufficienti per istanziare un oggetto della classe LP [rigo 34].
			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">

import it.ssc.log.SscLogger;
import it.ssc.pl.milp.ConsType;
import it.ssc.pl.milp.Constraint;
import it.ssc.pl.milp.GoalType;
import it.ssc.pl.milp.LP;
import it.ssc.pl.milp.LinearObjectiveFunction;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.pl.milp.ListConstraints;
import java.util.ArrayList;


public class Esempio {

	public static void main(String[] args) throws Exception {

		double A[][]={ 
				{ 1.0 , 1.0 },
				{ 1.0 , 1.4 },
				{-5.0 , 3.0 } } ;
		double b[]= {-1.0, 6.0 ,5.0 };
		double c[]= { 1.0, 3.0  };	

		ConsType[] rel= {ConsType.GE, ConsType.LE, ConsType.EQ};

		LinearObjectiveFunction fo = new LinearObjectiveFunction(c, GoalType.MAX);

		ListConstraints constraints = new ListConstraints();
		for(int i=0; i < A.length; i++) {
			constraints.add(new Constraint(A[i], rel[i], b[i]));
		}

		LP lp = new LP(fo,constraints); 
		SolutionType solution_type=lp.resolve();

		if(solution_type==SolutionType.OPTIMUM) { 
			Solution solution=lp.getSolution();
			for(Variable var:solution.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
		}	
	}
}
			</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>





















			<h3 class="paragraph_title">
				<a id="ese1_3">Esempio 1.3</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di LP : <br> <br>
				<pre>
	 max  X<sub>1</sub> +   3X<sub>2</sub>
	 
	      X<sub>1</sub> +    X<sub>2</sub> &#x2265; 1
   	      X<sub>1</sub> + 1.4X<sub>2</sub> &#x2264; 6
   	    -5X<sub>1</sub> +   3X<sub>2</sub> = 5
   	    
   	 con -1 &#x2264; X<sub>1</sub> &#x2264; +1
   	     -&infin; &#x2264; X<sub>2</sub> &#x2264; +&infin;  
</pre>
				<br> In questo esempio la variabile X<sub>1</sub>
				risulta delimitata sia inferiormente (non dallo zero) che
				superiormente. Nella rappresentazione del problema in formato a coefficienti,
				per poter definire una variabile con tali limiti,
				basta aggiungere un rigo per gli upper bound e uno per i lower
				bound [righi 16-17]. Nel caso della variabile X<sub>2</sub>
				(ovvero di una variabile senza limiti), basta specificare
				un lower bound e un upper bound indefinito (rappresentato dal "."). 
				<br><br>
				&Egrave; importante sottolineare che per 
				poter impostare delle variabili libere, ovvero delle variabili che possono assumere anche valori negativi, 
				basta valorizzare un lower bound indefinito (.) o negativo,
				oppure un upper bound negativo. Al contrario, introdurre un vincolo del tipo X<sub>1</sub>  &#x2265; -1, 
				(ovvero un vincolo di tipo GE) non determina che la variabile diventi libera, ma si vincola solo il problema a soddisfare 
				tale condizione; condizione che non potr&agrave; essere vagliata pienamente (permettendo alla variabile di assumere valori negativi) se non  si rende la variabile effettivamente libera.  
				Per renderla libera  si deve usare esclusivamente la notazione degli upper e lower bound. 
				In questo esempio sia X<sub>1</sub> che X<sub>2</sub> sono variabili libere.
				<br><br>
				
				Infine in fase di stampa della soluzione 
				&egrave; possibile recuperare per ogni variabile gli upper ed i lower precedentemente valorizzati 
				in fase di formulazione del problema [rigo 29].

			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">
import it.ssc.log.SscLogger;
import it.ssc.pl.milp.LP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.ref.InputString;
 
public class Esempio {
    public static void main(String[] args) throws Exception {
 
        String lp_string = 
                            " 1    3    max      .    \n" + 
                            " 1    1    ge       1    \n" + 
                            " 1  1.4    le       6    \n" +
                            "-5    3    eq       5    \n" + 
                            " 1    .    upper    .    \n" +
                            "-1    .    lower    .    \n" ; 
             
 
        InputString lp_input = new InputString(lp_string); 
        lp_input.setInputFormat("X1-X2:double, TYPE:varstring(8), RHS:double"); 
 
        LP lp = new LP(lp_input); 
        SolutionType solution_type=lp.resolve();
             
        if(solution_type==SolutionType.OPTIMUM) {
            Solution solution=lp.getSolution();
            for(Variable var:solution.getVariables()) {
                SscLogger.log("Variabile "+var.getName() +": "+var.getLower() + " <= ["+var.getValue()+"] <= "+var.getUpper());
            }
            SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
        }   
    }
}
			</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>













































			<h3 class="paragraph_title">
				<a id="ese1_4">Esempio 1.4</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di LP riportato nell'esempio
				precedente: <br> <br>
				<pre>
	 max  X<sub>1</sub> +   3X<sub>2</sub>
	 
	      X<sub>1</sub> +    X<sub>2</sub> &#x2265; 1
   	      X<sub>1</sub> + 1.4X<sub>2</sub> &#x2264; 6
   	    -5X<sub>1</sub> +   3X<sub>2</sub> = 5
   	    
   	 con -1 &#x2264; X<sub>1</sub> &#x2264; +1
   	     -&infin; &#x2264; X<sub>2</sub> &#x2264; +&infin;  
</pre>
				<br> Risolviamo  l'esempio
				precedente utilizzando il formato matriciale. Per poter rappresentare la
				variabile X<sub>1</sub>, che risulta delimitata sia inferiormente che
				superiormente, occorre aggiungere alla matrice A  un rigo
				per gli upper bound e uno per i lower bound [righi 21-22]. Nel caso della variabile X<sub>2</sub>, ovvero di una
				variabile libera senza limiti , basta specificare un  lower bound e un upper bound
				indefinito con il valore NaN.<br><br> 
				Ricordiamo che per poter impostare delle variabili libere, ovvero delle variabili che possono assumere anche valori negativi, 
				basta valorizzare un lower bound indefinito (.) o negativo,
				oppure un upper bound negativo. In questo esempio sia X<sub>1</sub> che X<sub>2</sub> sono libere.
				
				<br> <br> Occorre poi aggiungere nel 
				vettore delle relazioni [rigo 27] le costanti che dichiarano
				che gli ultimi due righi della matrice A sono relativi agli upper e
				lower bound (si aggiunge ConsType.UPPER e ConsType.LOWER). Infine, va
				aggiornata anche la dimensione del vettore b (aggiungendo due valori NaN) che deve essere
				uguale al numero di righi della matrice A.

			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">
import it.ssc.log.SscLogger;
import it.ssc.pl.milp.ConsType;
import it.ssc.pl.milp.Constraint;
import it.ssc.pl.milp.GoalType;
import it.ssc.pl.milp.LP;
import it.ssc.pl.milp.LinearObjectiveFunction;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import static it.ssc.pl.milp.LP.NaN;
import java.util.ArrayList;

public class Esempio {
	
	public static void main(String[] args) throws Exception {

		double A[][]={ 
				{ 1.0 , 1.0  },
				{ 1.0 , 1.4  },
				{-5.0 , 3.0  },
				{ 1.0 , NaN },
				{-1.0 , NaN }} ;
		
		double b[]= { 1.0, 6.0 ,5.0, NaN, NaN };
		double c[]= { 1.0, 3.0  };	

		ConsType[] rel= {ConsType.GE, ConsType.LE, ConsType.EQ, ConsType.UPPER, ConsType.LOWER};

		LinearObjectiveFunction f = new LinearObjectiveFunction(c, GoalType.MAX);

		ArrayList< Constraint > constraints = new ArrayList< Constraint >();
		for(int i=0; i < A.length; i++) {
			constraints.add(new Constraint(A[i], rel[i], b[i]));
		}

		LP lp = new LP(f,constraints); 
		SolutionType solution_type=lp.resolve();

		if(solution_type==SolutionType.OPTIMUM) { 
			Solution solution=lp.getSolution();
			for(Variable var:solution.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
		}	
	}
}
			

			</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>




















	<h3 class="paragraph_title">
				<a id="ese1_5">Esempio 1.5</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di LP : <br> <br>
				<pre>
	
   	 min  3Y +  X<sub>2</sub> + 4X<sub>3</sub> + 7X<sub>4</sub> + 8X<sub>5</sub>
   	 
   	      5Y + 2X<sub>2</sub>     <sub> </sub> + 3X<sub>4</sub>     <sub> </sub>  &#x2265;   9
   	      3Y +  X<sub>2</sub> +  X<sub>3</sub>     <sub> </sub> + 5X<sub>5</sub>  &#x2265;  12
   	      6Y + 3X<sub>2</sub> + 4X<sub>3</sub> + 5X<sub>4</sub>     <sub> </sub>  &#x2264; 124
   	       Y + 3X<sub>2</sub>     <sub> </sub> + 3X<sub>4</sub> + 6X<sub>5</sub>  &#x2264; 854
   	      
   	 con Y, X<sub>2</sub>, X<sub>3</sub>, X<sub>4</sub>, X<sub>5</sub> &#x2265; 0
   	   
				</pre>
				<br> Vogliamo risolvere questo problema usando un altro formato di rappresentazione denominato a 
				disequazioni. In questo formato la funzione obiettivo e i vincoli  possono essere espressi mediante equazioni/disequazioni rappresentate all'interno 
				di stringhe [righi 17-21]. Le variabili possono avere qualsiasi nome (devono per&ograve; iniziare con un carattere alfabetico seguito da caratteri alfanumerici) 
				e risultano non essere case-sensitive (ovvero x3 e X3 rappresentano la stessa variabile).  
				
				<br><br>
				Uno dei vantaggi di questo formato &egrave; che se una variabile non &egrave; presente in un vincolo questa pu&ograve; essere
				tralasciata, a differenza del formato matriciale o a coefficienti dove deve essere rappresentata con un 
				coefficiente uguale a zero. E' importante ricordare che la totalit&agrave; delle variabili del problema devono per&ograve; essere
				espresse nella funzione obiettivo. 
				

			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">
				
import java.util.ArrayList;
import it.ssc.log.SscLogger;
import it.ssc.pl.milp.GoalType;
import it.ssc.pl.milp.LP;
import it.ssc.pl.milp.LinearObjectiveFunction;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;

public class Esempio {
	
	public static void main(String[] args) throws Exception {

		
		ArrayList< String > constraints = new ArrayList< String >();
		constraints.add("min:  3Y +2x2 +4x3 +7x4 +8X5 "); 
		constraints.add("5Y +2x2 +3X4       >= 9");
		constraints.add("3Y + X2 +X3 +5X5   >= 12");
		constraints.add("6Y+3.0x2 +4X3 +5X4 <= 124");
		constraints.add(" y + 3x2 +3X4 +6X5 <= 854");
		
		LP lp = new LP(constraints); 
		SolutionType solution_type=lp.resolve();
		
		if(solution_type==SolutionType.OPTIMUM) {
			Solution soluzione=lp.getSolution();
			for(Variable var:soluzione.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore :"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+soluzione.getOptimumValue());
		}
	}
}


			</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>


















	<h3 class="paragraph_title">
				<a id="ese1_6">Esempio 1.6</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di LP : <br> <br>
				<pre>
	
   	 min  3Y +  X<sub>2</sub> + 4Z + 7X<sub>4</sub> + 8X<sub>5</sub>
   	 
   	      5Y + 2X<sub>2</sub>     <sub> </sub> + 3X<sub>4</sub>     <sub> </sub>  &#x2265;   9
   	      3Y +  X<sub>2</sub> +  Z     <sub> </sub> + 5X<sub>5</sub>  &#x2265;  12
   	      6Y + 3X<sub>2</sub> + 4Z + 5X<sub>4</sub>     <sub> </sub>  &#x2264; 124
   	       Y + 3X<sub>2</sub>     <sub> </sub> + 3X<sub>4</sub> + 6X<sub>5</sub>  &#x2264; 854
   	      
   	 con Y, X<sub>4</sub>, X<sub>5</sub> &#x2265; 0
   	    -1 &#x2264; X<sub>2</sub> &#x2264; +6
   	     1 &#x2264; Z &#x2264; +&infin;     
				</pre>
				<br> Vogliamo risolvere questo problema usando il formato di rappresentazione a 
				disequazioni. In questo formato per definire gli upper e lower bound occorre aggiunge rispettivamente un rigo 
				per ogni variabile da limitare [righi 15-16].  

			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">


import java.util.ArrayList;
import it.ssc.log.SscLogger;
import it.ssc.pl.milp.*;

public class Esempio {
	
	public static void main(String[] args) throws Exception {
		
		ArrayList< String > constraints = new ArrayList< String >();
		constraints.add("min:  3Y +2x2   +4Z +7x4 +8X5 ");
		constraints.add("      5Y +2x2       +3X4      >= 9");
		constraints.add("      3Y + X2   + Z       +5X5 >= 12");
		constraints.add("      6Y +3.0x2 +4Z +5X4      <= 124");
		constraints.add("       Y +3x2       +3X4 +6X5 <= 854");
		constraints.add("-1<=  x2 <= 6");
		constraints.add("1 <=  z  <= .");
			
		LP lp = new LP(constraints); 
		SolutionType solution_type=lp.resolve();
		
		if(solution_type==SolutionType.OPTIMUM) {
			Solution soluzione=lp.getSolution();
			for(Variable var:soluzione.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore :"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+soluzione.getOptimumValue());
		}
	}
}

			</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>










































			<h3 class="paragraph_title">
				<a id="ese1_7">Esempio 1.7</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di LP riportato nell'esempio
				1.4: <br> <br>
				<pre>
	 max  X<sub>1</sub> +   3X<sub>2</sub>
	 
	      X<sub>1</sub> +    X<sub>2</sub> &#x2265; 1
   	      X<sub>1</sub> + 1.4X<sub>2</sub> &#x2264; 6
   	    -5X<sub>1</sub> +   3X<sub>2</sub> = 5
   	    
   	 con -1 &#x2264; X<sub>1</sub> &#x2264; +1
   	     -&infin; &#x2264; X<sub>2</sub> &#x2264; +&infin;  
</pre>
				<br> L'esempio 1.4 pu&ograve; essere rappresentato  con un
				quarto formato denominato "sparso" [righi 17-40]. Ogni
				espressione del tipo EQ, LE, GE, UPPER, LOWER, MAX, MIN, ha associato un nome (nome del rigo).
				Tale nome inizialmente viene dichiarato nella colonna dei ROW_ con associato un TYPE 
				per indicarne appunto la tipologia [righi 17-22]. 
				La colonna TYPE pu&ograve; assumere di conseguenza solo uno dei seguenti valori: EQ, LE, GE, UPPER, LOWER,
				MAX, MIN. <br> <br>Successivamente vanno dichiarate le
				variabili del problema valorizzando la colonna COL_,  attraverso questa colonna si  esprimere il valore che la variabile assume su quel rigo . 
				Oltre alle 	variabili, nella COL_ va  indicato anche il marcatore dei valori rhs. Se i
				nomi delle variabili possono essere qualsiasi, il marcatore
				dei valori rhs deve essere espresso necessariamente con la notazione RHS. In definitiva la 
				definizione del coefficiente che ogni variabile assume su ogni rigo 
				si effettua valorizzando, per ogni combinazione ROW_ e COL_, il
				relativo valore nella colonna COEF. Definito il problema 
				occorre dichiarare nel formato di lettura [rigo 44] il nome e il tipo (con la relativa lunghezza)
				delle quattro entit&agrave; richieste da questo formato : 
				TYPE, COL_, ROW_ e COEF. 
				
				<br> <br> 
				Per poter istanziare con questo formato un oggetto LP occorre passare come argomento 
				al costruttore la costante FormatType.SPARSE per informare l'oggetto LP del tipo di formato utilizzato [rigo 46]. 				
				
				Questo formato &egrave;
				particolarmente indicato per prelevare problemi presenti in tabelle
				di database, in quanto la struttura della tabella richiesta &egrave;
				sempre la stessa: basta che questa definisca le colonne TYPE, COL_,
				ROW_ e COEF. 
				
				<br> <br> Occorre infine ricordare che i
				valori della colonna TYPE e COL_ possono essere espressi sia in
				maiuscolo che in minuscolo; in entrambi i casi essi verranno
				ricondotti al maiuscolo; mentre per la colonna ROW_ esprimere
				il nome di un rigo contemporaneamente in minuscolo e 
				in maiuscolo, nell'ambito di una stessa formulazione, significa dichiarare
				due nomi (e quindi due righi ) distinti.


			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">

import it.ssc.log.SscLogger;
import it.ssc.pl.milp.FormatTypeInput.FormatType;
import it.ssc.pl.milp.LP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.ref.InputString;

public class Esempio {
	
	public static void main(String[] args) throws Exception {

		String lp_sparse = 
		
			//    TYPE   COL_   ROW_    COEF 
				 
				" MAX     .    costo      .    \n" +   
                " GE      .    row1       .    \n" +	  
                " LE      .    row2       .    \n" +  
                " EQ      .    row3       .    \n" +
                " UPPER   .    lim_sup    .    \n" +
                " LOWER   .    lim_inf    .    \n" +              
		
				" .      X1    costo      1    \n" +
				" .      X1    row1       1    \n" +	  
		        " .      X1    row2       1    \n" +  
		        " .      X1    row3      -5    \n" +
		        " .      X1    lim_sup    1    \n" +
		        " .      X1    lim_inf   -1    \n" +		       
				 
				" .      X2    costo      3    \n" +
				" .      X2    row1       1    \n" +	  
		        " .      X2    row2     1.4    \n" +  
		        " .      X2    row3       3    \n" +
		        " .      X2    lim_sup    .    \n" +
		        " .      X2    lim_inf    .    \n" +	       
		         
				" .      RHS   row1       1    \n" +	  
				" .      RHS   row2       6    \n" +  
				" .      RHS   row3       5    \n"   ;
			

		InputString lp_input = new InputString(lp_sparse); 
		lp_input.setInputFormat("TYPE:varstring(5), COL_:varstring(3) , ROW_:varstring(7), COEF:double"); 

		LP lp = new LP(lp_input,FormatType.SPARSE); 
		SolutionType solution_type=lp.resolve();
		
		if(solution_type==SolutionType.OPTIMUM) { 
			Solution solution=lp.getSolution();
			for(Variable var:solution.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
		}	
	}
}
			</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>









































			<h3 class="paragraph_title">
				<a id="ese1_8">Esempio 1.8</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di LP : <br> <br>
				<pre>
	
   	 min  3Y<sub>1</sub> +  Y<sub>2</sub> + 4Y<sub>3</sub> + 7Y<sub>4</sub> + 8Y<sub>5</sub>
   	 
   	      5Y<sub>1</sub> + 2Y<sub>2</sub>     <sub> </sub> + 3Y<sub>4</sub>     <sub> </sub>  &#x2265;   9
   	      3Y<sub>1</sub> +  Y<sub>2</sub> +  Y<sub>3</sub>     <sub> </sub> + 5Y<sub>5</sub>  &#x2265;  12
   	      6Y<sub>1</sub> + 3Y<sub>2</sub> + 4Y<sub>3</sub> + 5Y<sub>4</sub>     <sub> </sub>  &#x2264; 124
   	      1Y<sub>1</sub> + 3Y<sub>2</sub>     <sub> </sub> + 3Y<sub>4</sub> + 6Y<sub>5</sub>  &#x2264; 854
   	      
   	 con Y<sub>1</sub>, Y<sub>4</sub>, Y<sub>5</sub> &#x2265; 0
   	     0 &#x2264; Y<sub>2</sub> &#x2264; +6
   	     1 &#x2264; Y<sub>3</sub> &#x2264; +&infin;     
</pre>
				<br> In questo caso vogliamo risolvere un problema di LP la cui 
				formulazione si trova in un file di testo (.txt). Chiamiamo 
				tale file pl_problem.txt e 
				utilizziamo, per la rappresentazione del problema, il formato
				a coefficienti. Nel file pl_problem.txt avremo il seguente contenuto:

				<pre>
   	     
3 1 4 7 8 min      . 
5 2 0 3 0 ge       9 
3 1 1 0 5 ge       12
6 3 4 5 0 le       124
1 3 0 3 6 le       854
. 6 . . . upper    . 
0 0 1 0 0 lower    . 

</pre>

				Definito tale file di testo, occorre informare SSC che il problema 
				&egrave; contenuto nel file pl_problem.txt [rigo 12]. Se si hanno un numero
				significativo di variabili (in questo caso solo 5, ma possono essere
				molte di pi&ugrave;) queste si possono dichiarare mediante notazione
				ad intervallo [rigo 13], dove con la sintassi "Y1-Y5:double" si
				dichiarano 5 variabili distinte (Y1, Y2, Y3, Y4, Y5) di tipo double.

			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">


import it.ssc.log.SscLogger;
import it.ssc.pl.milp.LP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.ref.InputFile;

public class Example {
	
	public static void main(String[] args) throws Exception {

		InputFile input = new InputFile("c:/dati_pl/pl_problem.txt");
		input.setInputFormat("Y1-Y5:double, TYPE:varstring(10),  RHS:double");

		LP lp=new LP(input);
		SolutionType solution_type=lp.resolve();
		
		if(solution_type==SolutionType.OPTIMUM) {
			Solution soluzione=lp.getSolution();
			for(Variable var:soluzione.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore :"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+soluzione.getOptimumValue());
		}
	}
}
			</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>





























			<h3 class="paragraph_title">
				<a id="ese1_9">Esempio 1.9</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di LP riportato nell'esempio 1.7:
				<br> <br>
				<pre>
	 max  X<sub>1</sub> +   3X<sub>2</sub>
	 
	      X<sub>1</sub> +    X<sub>2</sub> &#x2265; 1
   	      X<sub>1</sub> + 1.4X<sub>2</sub> &#x2264; 6
   	    -5X<sub>1</sub> +   3X<sub>2</sub> = 5
   	    
   	 con -1 &#x2264; X<sub>1</sub> &#x2264; +1
   	     -&infin; &#x2264; X<sub>2</sub> &#x2264; +&infin;  
</pre>
				<br> In questo esempio vogliamo recuperare il problema, formulato nel formato sparso, da una
				tabella di un database (DB) Oracle. Ricordiamo che nel
				formato sparso l'input necessario per la risoluzione di un problema
				di LP richiede la presenza delle colonne TYPE, ROW_, COL_ e COEF.
				Per cui la tabella Orache che contiene il problema deve avere tali
				colonne. Chiamiamo questa tabella con il nome TAB_PL_PROBLEM,
				e creiamola con la seguente istruzione DDL :

				<pre>
CREATE TABLE  "TAB_PL_PROBLEM" 
  ("TYPE" VARCHAR2(5), 
   "COL_" VARCHAR2(3), 
   "ROW_" VARCHAR2(7), 
   "COEF" FLOAT(126)
  )
</pre>

				Infine, inseriamo nella tabella i seguenti record (per null si intende il valore
				null non la stringa "null"):
				<pre>

  MAX     null    costo      null   
  GE      null    row1       null    
  LE      null    row2       null   
  EQ      null    row3       null   
  UPPER   null    lim_sup    null   
  LOWER   null    lim_inf    null        
  null      X1    costo      1   
  null      X1    row1       1    
  null      X1    row2       1   
  null      X1    row3      -5   
  null      X1    lim_sup    1   
  null      X1    lim_inf   -1          
  null      X2    costo      3   
  null      X2    row1       1    
  null      X2    row2     1.4   
  null      X2    row3       3   
  null      X2    lim_sup    null   
  null      X2    lim_inf    null         
  null      RHS   row1       1    
  null      RHS   row2       6   
  null      RHS   row3       5   


</pre>
				Per poter recuperare la formulazione del problema da una tabella
				presente in un database, occorre scaricare il driver JDBC per il
				database in questione e istanziare un oggetto Connection [righi
				41-48]. Una volta ottenuta una connessione al DB, tramite l'oggetto
				Connection &egrave; possibile, da SSC, accedere al DB come se fosse
				una libreria, ovvero un contenitore di tabelle. SSC per poter
				allocare librerie necessita che venga creata una sessione di lavoro
				SSC. Una sessione SSC rappresenta l'ambiente nel quale SSC viene
				eseguito. Negli esempi precedenti la creazione di una sessione non
				era necessaria in quanto l'oggetto LP crea e usa una sua sessione
				SSC implicita. <br> <br> L'invocazione di addLibrary()
				[rigo 21] permette di aggiunge alla sessione SSC corrente una
				libreria (di nome "DB_ORACLE") che rappresenta una connessione al DB
				Oracle. Dopo tale invocazione il metodo addLibrary() ritorna un
				oggetto che rappresenta una interfaccia a tale contenitore. Da
				questa interfaccia possiamo [rigo 23] ottenere
				un oggetto di tipo Input che fa riferimento alla tabella
				"TAB_PL_PROBLEM". Una volta ottenuto tale input
				possiamo passarlo al
				costruttore LP [rigo 24] ed eseguire il Simplesso. <br> <br>
				
				
				E' da notare che nel costruttore della classe LP viene anche passato come
				argomento [rigo 24] la sessione SSC creata , questo per non far istanziare
				all'oggetto LP una seconda sessione del tutto inutile.



			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">

import it.ssc.context.Context;
import it.ssc.context.Session;
import it.ssc.library.Library;
import it.ssc.log.SscLogger;
import it.ssc.pl.milp.FormatTypeInput.FormatType;
import it.ssc.pl.milp.LP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.ref.Input;
import java.sql.Connection;
import oracle.jdbc.pool.OracleDataSource;
 
public class Esempio {
     
    public static void main(String[] args) throws Exception {
         
        Session session = null;
        try {
            session = Context.createNewSession();
            Library lib_ora=session.addLibrary("DB_ORACLE", connOracle());
         
            Input pl_oracle=lib_ora.getInput("TAB_PL_PROBLEM");
            LP lp = new LP(pl_oracle,session,FormatType.SPARSE); 
            SolutionType solution_type=lp.resolve();
             
            if(solution_type==SolutionType.OPTIMUM) { 
                Solution solution=lp.getSolution();
                for(Variable var:solution.getVariables()) {
                    SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
                }
                SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
            }   
        } 
        finally {
            session.close();
        }
    }
     
     
    private static Connection connOracle() throws Exception {
        OracleDataSource ods = new OracleDataSource();
        String URL = "jdbc:oracle:thin:@//192.168.243.134:1521/XE";
        ods.setURL(URL);
        ods.setUser("user_pl");
        ods.setPassword("ora655"); 
        return ods.getConnection();
    }
}

				</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>





























			<h3 class="paragraph_title">
				<a id="ese1_10">Esempio 1.10</a>
			</h3>
			<div class="commento">
				Nell'esempio sottostante si riporta un semplice problema di LP che
				 vuole evidenziare quali sono i valori che il
				metodo resolve() pu&ograve; restituire a seconda che il problema di
				LP :
				<br><br>
				a) restituisca una soluzione ottima<br>
				b) non ammetta soluzioni ammissibili<br>
				c) abbia ottimo illimitato<br>
				d) raggiunga il numero massimo di iterazioni possibili<br>
				e) venga restituita una soluzione ammissibile al posto di una soluzione ottima<br>
				
				
				<br>Se l'esigenza  &egrave; quella di ottenere una soluzione
				ammissibile non necessariamente ottima (caso e), basta invocare il metodo
				setJustTakeFeasibleSolution() passandogli il valore "true" (rigo 28). Questa opzione
				permette di far eseguire solo la prima fase del simplesso e di ottenere una prima soluzione 
				(basica) ammissibile. In questo caso il valore restituito dal metodo resolve() 
				(nel caso esista una soluzione ammissibile)
				sar&agrave; SolutionType.FEASIBLE.
 				<br>
				Infine ricordiamo che il numero massimo di iterazioni possibili pu&ograve;
				essere modificato dall'analista [rigo 27].
			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">
import it.ssc.log.SscLogger;
import it.ssc.pl.milp.LP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.ref.InputString;

public class Esempio {
	
	public static void main(String[] args) throws Exception {

		String lp_string = 
			                "5  4   1    3   max     .   \n" +  
			                "4  3   1    1   ge      2   \n" +	  
			                "1 -2   1   -1   le      2   \n" +	  		
			                "3  2   1  1.4   le      6   \n" +  
			                "9  8   4  1.7   le      7   \n" +  
			                "5  3  -1  2.4   le      9   \n" +  
			                "3 -2  -5    3   le      5      ";
			

		InputString lp_input = new InputString(lp_string); 
		lp_input.setInputFormat("V1-V4:double, TYPE:varstring(8), RHS:double"); 

		LP lp = new LP(lp_input); 
		SscLogger.log("Numero di iterazioni di default:"+lp.getNumMaxIteration());
		lp.setNumMaxIteration(5);
		lp.setJustTakeFeasibleSolution(true);  //imposto la ricerca di una soluzione ammissibile , 
		SolutionType solution_type=lp.resolve();
		
		if(solution_type==SolutionType.FEASIBLE) { 
			Solution solution=lp.getSolution();
			for(Variable var:solution.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
			}
			SscLogger.log("Valore assunto dalla soluzione ammissibile sulla f.o.:"+solution.getOptimumValue());
		}	
		else if(solution_type==SolutionType.VUOTUM) {
			SscLogger.log("La fase 1 del simplesso non ha trovato soluzioni ammissibili:("+solution_type+")");
		}
		else if(solution_type==SolutionType.ILLIMITATUM) {
			SscLogger.log("Ottimo illimitato:("+solution_type+")");
		}
		else if(solution_type==SolutionType.MAX_ITERATIUM) {
			SscLogger.log("Raggiunto il numero massimo di iterazioni:("+solution_type+")");
		}
		else if(solution_type==SolutionType.OPTIMUM) { 
			//questa sezione non verr&agrave; mai raggiunta in quanto avendo impostato 
			//setJustTakeFeasibleSolution(true), il simplesso pu&ograve; solo restituire soluzioni ammissibili
		}
		
	}
}

				</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>

































			<h3 class="paragraph_title">
				<a id="ese1_11">Esempio 1.11</a>
			</h3>
			<div class="commento">
				Nell'esempio sottostante si vuole risolvere  il problema gi&agrave; affrontato nell'esercizio 1.6, con la particolarit&agrave; 
				che la formulazione del problema (utilizzando il formato a disequazioni) &egrave; memorizzata in un file. Chiamiamo questo file
				pl_proble.txt. Il file menzionato conterr&agrave; il seguente contenuto: <br><br>
				
				<pre>
min:  3Y +2x2   +4Z +7x4 +8X5 
row1:5Y +2x2       +3X4      >= 9
row2:3Y + X2    +Z      +5X5 >= 12
Vin1:6Y +3.0x2 +4Z +5X4      <= 124
vin2: Y +3x2       +3X4 +6X5 <= 854
-1 <= x2 <= 6
 1 <=  z <= .
				</pre>
				
				A differenza della formulazione dell'esempio 1.6 in questo caso ad ogni vincolo abbiamo anche associato una etichetta 
				(nome del vincolo) che si inserisce anteponendo ad ogni vincolo un nome seguito da due punti. E' importante sottolineare che sui limiti di tipo upper e lower bound (ad esempio +3<=x<=+6)
				l'etichetta non va assolutamente inserita. 
			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">

import it.ssc.log.SscLogger;
import it.ssc.pl.milp.*;
import java.util.ArrayList;
import java.util.Random;

public class Esempio {
	
 public static void main(String[] args) throws Exception {
 
        LP lp = new LP("C:\\ssc_project\\ssc\\dati_testo\\pl_proble.txt");
        SolutionType solution_type=lp.resolve();
         
        if(solution_type==SolutionType.OPTIMUM) {
            Solution soluzione=lp.getSolution();
            for(Variable var:soluzione.getVariables()) {
                SscLogger.log("Nome variabile :"+var.getName() + " valore :"+var.getValue());
            }
            for(SolutionConstraint sol_constraint: soluzione.getSolutionConstraint()) {
                SscLogger.log("Vincolo "+sol_constraint.getName()+" : valore="+sol_constraint.getValue() + 
                              "[ "+sol_constraint.getRel()+"  "+sol_constraint.getRhs()+" ]" );
            }
            SscLogger.log("Valore ottimo:"+soluzione.getOptimumValue());
        }
    }
}
				</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>














			<h3 class="paragraph_title">
				<a id="ese1_12">Esempio 1.12</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di LP identico all'esempio 1.9:
				<br> <br>
				<pre>
	 max  X<sub>1</sub> +   3X<sub>2</sub>
	 
	      X<sub>1</sub> +    X<sub>2</sub> &#x2265; 1
   	      X<sub>1</sub> + 1.4X<sub>2</sub> &#x2264; 6
   	    -5X<sub>1</sub> +   3X<sub>2</sub> = 5
   	    
   	 con -1 &#x2264; X<sub>1</sub> &#x2264; +1
   	     -&infin; &#x2264; X<sub>2</sub> &#x2264; +&infin;  
</pre>
				<br> In questo esempio vogliamo recuperare il problema, formulato nel formato sparso, da un
				file di testo chiamato sparse_problem.txt contenete il seguente listato:

			
				<pre>

  MAX     .    costo      .   
  GE      .    row1       .    
  LE      .    row2       .   
  EQ      .    row3       .   
  UPPER   .    lim_sup    .   
  LOWER   .    lim_inf    .        
  .      X1    costo      1   
  .      X1    row1       1    
  .      X1    row2       1   
  .      X1    row3      -5   
  .      X1    lim_sup    1   
  .      X1    lim_inf   -1          
  .      X2    costo      3   
  .      X2    row1       1    
  .      X2    row2     1.4   
  .      X2    row3       3   
  .      X2    lim_sup    .   
  .      X2    lim_inf    .         
  .      RHS   row1       1    
  .      RHS   row2       6   
  .      RHS   row3       5   


</pre>
			
				
				
				E' da notare che nel costruttore della classe LP viene passato come
				argomento un oggetto di tipo InputFile che fa riferimento al file contenente il problema.



			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">
import it.ssc.log.SscLogger;
import it.ssc.pl.milp.FormatTypeInput.FormatType;
import it.ssc.pl.milp.LP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.ref.InputFile;

public class Esempio {
     
    public static void main(String[] args) throws Exception {
         
        InputFile input_sparse = new InputFile("C:/ssc_project/sparse_problem.txt");
       	input_sparse.setInputFormat("TYPE:varstring(5), COL_:varstring(3) , ROW_:varstring(7), COEF:double"); 
        LP lp = new LP(input_sparse,FormatType.SPARSE);  
        SolutionType solution_type=lp.resolve();
            
        if(solution_type==SolutionType.OPTIMUM) { 
            Solution solution=lp.getSolution();
            for(Variable var:solution.getVariables()) {
                SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
            }
            SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
        }   
       
    }
}
				</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>
































	<h3 class="paragraph_title">
				<a id="ese1_13">Esempio 1.13</a>
			</h3>
			<div class="commento">
				Nell'esempio sottostante si riporta un problema di LP generato con 
				numeri pseudocausali, con la particolarit&agrave; che al vettore b vengono fatti assumere valori dell'ordine di 
				decine di milioni. La conseguenza di lavorare con numeri di elevata grandezza potrebbe non far convergere 
				la fase 1 del simplesso. 
				In questo particolare caso  se non si modifica 
				la tolleranza &epsilon;  del valore ottimo z della f.o relativo alla fase 1 la risoluzione del problema potrebbe non dare come risultato soluzioni ammissibili. 
				In altre parole, alla fine della fase 1,  se | z | > &epsilon; allora il problema non ammette soluzioni. 
				Per ovviare a questo, nell'esempio riportato, la tolleranza viene aumentata da 1E-8 (valore di default) a 1E-5 [rigo 31] per far si che , a causa 
				della manipolazione di numeri di grandezza elevata, possa avvenire che | z | < &epsilon;. 
			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">

import it.ssc.log.SscLogger;
import it.ssc.pl.milp.*;
import java.util.ArrayList;
import java.util.Random;
 
public class Esempio {
    public static void main(String arg[]) throws Exception {
         
        final int M = 445;  // rows
        final int N = 345;  // cols
         
        Random random = new Random();
         
        double[] c = new double[N];
        double[] b = new double[M];
        double[][] A = new double[M][N];
        for (int j = 0; j < N; j++)      c[j] = (double) (random.nextInt(20));
        for (int i = 0; i < M; i++)      b[i] = (double) random.nextInt(100000000);
        for (int i = 0; i < M; i++)
            for (int j = 0; j < N; j++)  A[i][j] = (double) random.nextInt(10);
                 
 
        LinearObjectiveFunction f = new LinearObjectiveFunction(c, GoalType.MAX);
 
        ArrayList< Constraint > constraints = new ArrayList< Constraint >();
        for(int i=0; i < A.length; i++) {
            constraints.add(new Constraint(A[i], ConsType.LE, b[i])); 
        }
        
        LP lp = new LP(f,constraints);
        lp.setCEpsilon(EPSILON._1E_M5);
        SolutionType solution_type=lp.resolve();
 
        if(solution_type==SolutionType.OPTIMUM) { 
            Solution solution=lp.getSolution();
            for(Variable var:solution.getVariables()) {
                SscLogger.log("Nome variabile :"+var.getName() + " value:"+var.getValue());
            }
            SscLogger.log("Valore f.o. :"+solution.getOptimumValue());  
        }
        else SscLogger.log("Soluzione non ottima. Tipo di soluzione:"+solution_type);
    }
}
 
				</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>































			<h3 class="paragraph_title">
				<a id="ese1_14">Esempio 1.14</a>
			</h3>

			<div class="commento">
				Si consideri il seguente problema di LP: <br> <br>
<pre>
	 max  X<sub>1</sub> +   3X<sub>2</sub>
	 
	      X<sub>1</sub> +    X<sub>2</sub> &#x2265;-1
   	      X<sub>1</sub> + 1.4X<sub>2</sub> &#x2264; 6
   	    -5X<sub>1</sub> +   3X<sub>2</sub> = 5
   	    
   	 con X<sub>1</sub>, X<sub>2</sub> &#x2265; 0
</pre>
				<br> Per risolvere questo problema (identico al problema 1.1) con una implementazione del simplesso parallelo, 
				occorre semplicemente aggiungere l'istruzione presente nel rigo 24. Con questa istruzione specifichiamo il numero di thread 
				da utilizare per eseguire una istanza del simplesso parallelo (in questo caso 4). Tra i valori selezionabili vi &egrave; anche il valore 
				LPThreadsNumber.AUTO, con il quale si delega al sistema la scelta del numero di thread da utilizzare per l'esecuzione del simplesso parallelo. 
				Occorre ricordare che vantaggi sulla durata
				del metodo si ottengono con almeno 4 o pi&ugrave; core fisici e che ha senso utilizzare questa tecnica  
				 solo se il problema presenta un numero di variabili/vincoli dell'ordine dei migliaia. 
			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">

import it.ssc.log.SscLogger;
import it.ssc.pl.milp.LP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.ref.InputString;
import it.ssc.pl.milp.util.LPThreadsNumber;

public class Esempio {
	
	public static void main(String[] args) throws Exception {

		String lp_string = 
			                " 1    3    max      .    \n" +  
			                " 1    1    ge      -1    \n" +	  
			                " 1  1.4    le       6    \n" +  
			                "-5    3    eq       5";
			

		InputString lp_input = new InputString(lp_string); 
		lp_input.setInputFormat("X1:double, X2:double, TYPE:varstring(3), RHS:double"); 

		LP lp = new LP(lp_input); 
		lp.setThreadsNumber(LPThreadsNumber.N_4);
		SolutionType solution_type=lp.resolve();
		
		if(solution_type==SolutionType.OPTIMUM) { 
			Solution solution=lp.getSolution();
			for(Variable var:solution.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
		}	
		else SscLogger.log("Soluzione non ottima:"+solution_type);
	}
}
				</pre>
							

			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>

























































			<h3 class="paragraph_title"><a id="ese2_1">Example 2.1</h3>
			<div class="commento">
				Consideriamo il seguente problema di programmazione lineare misto-intera (MILP) : <br> <br>
				<pre>
	
   	 min  3X<sub>1</sub> +  X<sub>2</sub> + 4X<sub>3</sub> + 7X<sub>4</sub> + 8X<sub>5</sub>
   	 
   	      5X<sub>1</sub> + 2X<sub>2</sub>     <sub> </sub> + 3X<sub>4</sub>     <sub> </sub>  &#x2264;   9
   	      3X<sub>1</sub> +  X<sub>2</sub> +  X<sub>3</sub>     <sub> </sub> + 5X<sub>5</sub>  &#x2265;  12
   	      6X<sub>1</sub> + 3X<sub>2</sub> + 4X<sub>3</sub> + 5X<sub>4</sub>     <sub> </sub>  &#x2265; 124
   	      1X<sub>1</sub> + 3X<sub>2</sub>     <sub> </sub> + 3X<sub>4</sub> + 6X<sub>5</sub>  &#x2265; 854
   	      
   	 con X<sub>2</sub>, X<sub>3</sub>, X<sub>4</sub>, X<sub>5 </sub> &#x2208; &#x2124; 
   	     1 &#x2264; X<sub>2</sub> &#x2264; +6
   	     1 &#x2264; X<sub>3</sub> &#x2264; +&infin;     
   	     X<sub>1</sub>, X<sub>4</sub>, X<sub>5</sub> &#x2265; 0
</pre>
				<br> 
				
				
				
				Questo problema presenta le variabili X<sub>2</sub>, X<sub>3</sub>,
				X<sub>4</sub>, X<sub>5 </sub> intere, mentre la variabile X<sub>1</sub>
				non lo &egrave;. In SSC per risolvere un problema di MILP occorre
				semplicemente introdurre nel formato a coefficienti un rigo aggiuntivo
				[rigo 20] per dichiarare le variabili intere. Ponendo 1 sul rigo degli "integer"
				si dichiara la relativa variabile come intera. <br>
				<br> Altra differenza &egrave; che in questo caso va
				instanziato l'oggetto MILP [rigo 25] e non l'oggetto LP.

			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">


import it.ssc.log.SscLogger;
import it.ssc.pl.milp.MILP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.ref.InputString;

public class Esempio {
	public static void main(String[] args) throws Exception {

		String milp_string=
				
						"3 1 4 7 8 min      . "  +"\n"+
						"5 2 0 3 0 le       9 "  +"\n"+
						"3 1 1 0 5 ge       12"  +"\n"+
						"6 3 4 5 0 ge       124" +"\n"+
						"1 3 0 3 6 ge       854" +"\n"+
						"0 1 1 0 0 lower    . "  +"\n"+
						". 6 . . . upper    . "  +"\n"+
						"0 1 1 1 1 integer  . "  +"\n" ;  

		InputString milp_input = new InputString(milp_string);
		milp_input.setInputFormat("X1-X5:double, TYPE:varstring(20),  RHS:double");

		MILP milp=new MILP(milp_input);
		SolutionType solution_type= milp.resolve();

		if(solution_type==SolutionType.OPTIMUM) { 
			Solution solution=milp.getSolution();
			for(Variable var:solution.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
		}	
	}
}
				</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>

























			<h3 class="paragraph_title">
				<a id="ese2_2">Esempio 2.2</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di MILP dato da: <br> <br>
				<pre>
	 max  X<sub>1</sub> + 3.0X<sub>2</sub>
	 
	      X<sub>1</sub> +    X<sub>2</sub> &#x2265; 1
   	      X<sub>1</sub> + 1.4X<sub>2</sub> &#x2264; 6
   	    -5X<sub>1</sub> + 3.0X<sub>2</sub> &#x2264; 5
   	    
   	 con  X<sub>1</sub>, X<sub>2</sub> &#x2265; 0
   	      X<sub>1</sub>, X<sub>2</sub> &#x2208; &#x2124; 
</pre>
				<br> Vogliamo risolvere questo problema di programmazione
				lineare intera utilizzando la notazione matriciale. Per far ci&ograve; 
				basta aggiungere alla matrice A dei coefficienti un rigo
				per esprimere quali sono le variabili intere [rigo 21]. Con il valore 1
				si dichiara la variabile intera, con lo 0 la si considera non
				intera. Occorre anche dichiarare a SSC che l'ulteriore rigo
				inserito in A non &egrave; relativo ai vincoli di tipo GE, LE ,EQ ,
				ma alla dichiarazione delle variabili intere; ci&ograve; si realizza
				aggiungendo al vettore che esprime il tipo di vincolo
				(array rel[]) il valore ConsType.INT [rigo 26]. Infine occorre aggiungere al
				vettore b un valore NaN [rigo 23], per adeguare la dimensione di A
				con quella di b in quanto la dimensione di b deve coincidere con il
				numero di righi della matrice A.
			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">

import it.ssc.log.SscLogger;
import it.ssc.pl.milp.ConsType;
import it.ssc.pl.milp.Constraint;
import it.ssc.pl.milp.GoalType;
import it.ssc.pl.milp.LinearObjectiveFunction;
import it.ssc.pl.milp.MILP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import static it.ssc.pl.milp.LP.NaN;
import java.util.ArrayList;

public class Esempio {
	
	public static void main(String[] args) throws Exception {

		double A[][]={ 
				{ 1.0 , 1.0 },
				{ 1.0 , 1.4 },
				{-5.0 , 3.0 }, 
				{ 1.0 , 1.0 },  //rigo della matrice per la definizione degli integer
				} ;
		double b[]= { 1.0, 6.0 ,5.0, NaN};
		double c[]= { 1.0, 3.0  };	

		ConsType[] rel= {ConsType.GE, ConsType.LE, ConsType.LE, ConsType.INT};

		LinearObjectiveFunction f = new LinearObjectiveFunction(c, GoalType.MAX);

		ArrayList< Constraint > constraints = new ArrayList< Constraint >();
		for(int i=0; i < A.length; i++) {
			constraints.add(new Constraint(A[i], rel[i], b[i]));
		}

		MILP lp = new MILP(f,constraints); 
		SolutionType solution_type=lp.resolve();

		if(solution_type==SolutionType.OPTIMUM) { 
			Solution solution=lp.getSolution();
			for(Variable var:solution.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
		}	
	}
}
			</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>





































			<h3 class="paragraph_title">
				<a id="ese2_3">Esempio 2.3</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di MILP : <br> <br>
				<pre>
	 max  Y<sub>1</sub> + 3.0Y<sub>2</sub>
	 
	      Y<sub>1</sub> +    Y<sub>2</sub> &#x2265; 1
   	      Y<sub>1</sub> + 1.4Y<sub>2</sub> &#x2264; 6
   	    -5Y<sub>1</sub> + 3.0Y<sub>2</sub> = 5
   	    
   	 con  Y<sub>2</sub> &#x2208; &#x2124;
   	     -1 &#x2264; Y<sub>1</sub> &#x2264; +1
   	     -&infin; &#x2264; Y<sub>2</sub> &#x2264; +&infin;  
</pre>
				<br> Vogliamo risolvere questo problema di programmazione
				lineare misto intera utilizzando la notazione sparsa. Per indicare
				che la variabile Y<sub>2</sub> &egrave; intera basta aggiungere
				nella colonna dei ROW_ un valore per indicare quale sar&agrave; il
				marcatore che le definisce. Questo marcatore (da noi chiamato
				"var_int", ma pu&ograve; avere qualsiasi altro nome) deve avere
				associato un TYPE di tipo INTEGER [rigo 23].<br>
				<br> Una volta definito il marcatore che definisce le variabili
				intere, basta dichiarare [rigo 38] che la variabile Y<sub>2</sub>
				&egrave; di tipo var_int (ovvero INTEGER) ponendo nella colona dei
				COEF il valore 1. Se al contrario una variabile non &egrave; intera
				si deve valorizzare la colonna COEF con lo 0 o, pi&ugrave; brevemente, 
				tralasciare l'intera dichiarazione. Difatti, nella
				formulazione sottostante, la variabile Y<sub>1</sub> non &egrave; intera e
				quindi non &egrave; necessario esprimere la mancata associazione tra la 
				variabile e il marcatore var_int ponendo il valore 0 in COEF.


			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">

import it.ssc.log.SscLogger;
import it.ssc.pl.milp.FormatTypeInput.FormatType;
import it.ssc.pl.milp.MILP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.ref.InputString;

public class Esempio {
	public static void main(String[] args) throws Exception {

		String lp_sparse = 
		
		
			//    TYPE   COL_   ROW_    COEF 
				 
				" MAX     .    costo      .    \n" +   
                " GE      .    row1       .    \n" +	  
                " LE      .    row2       .    \n" +  
                " EQ      .    row3       .    \n" +
                " UPPER   .    lim_sup    .    \n" +
                " LOWER   .    lim_inf    .    \n" +    
                " INTEGER .    var_int    .    \n" +  
		
				" .      Y1    costo      1    \n" +
				" .      Y1    row1       1    \n" +	  
		        " .      Y1    row2       1    \n" +  
		        " .      Y1    row3      -5    \n" +
		        " .      Y1    lim_sup    1    \n" +
		        " .      Y1    lim_inf   -1    \n" +		       
				 
				" .      Y2    costo      3    \n" +
				" .      Y2    row1       1    \n" +	  
		        " .      Y2    row2     1.4    \n" +  
		        " .      Y2    row3       3    \n" +
		        " .      Y2    lim_sup    .    \n" +
		        " .      Y2    lim_inf    .    \n" +	
		        " .      Y2    var_int    1    \n" +
		         
				" .     RHS    row1       1    \n" +	  
				" .     RHS    row2       6    \n" +  
				" .     RHS    row3       5    \n"   ;
			

		InputString lp_input = new InputString(lp_sparse); 
		lp_input.setInputFormat("TYPE:varstring(7), COL_:varstring(3) , ROW_:varstring(7), COEF:double"); 

		MILP lp = new MILP(lp_input,FormatType.SPARSE); 
		SolutionType solution_type=lp.resolve();
		
		if(solution_type==SolutionType.OPTIMUM) { 
			Solution solution=lp.getSolution();
			for(Variable var:solution.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
		}	
	}
}
			</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>



















			<h3 class="paragraph_title">
				<a id="ese2_4">Esempio 2.4</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di programmazione  lineare misto intera
				(MILP) con alcune variabili binarie: <br> <br>
				<pre>
	
   	 min  3K<sub>1</sub> +  K<sub>2</sub> + 4K<sub>3</sub> + 7K<sub>4</sub> + 8K<sub>5</sub>
   	 
   	      5K<sub>1</sub> + 2K<sub>2</sub>     <sub> </sub> + 3K<sub>4</sub>     <sub> </sub>  &#x2264;   9
   	      3K<sub>1</sub> +  K<sub>2</sub> +  K<sub>3</sub>     <sub> </sub> + 5K<sub>5</sub>  &#x2265;  12
   	      6K<sub>1</sub> + 3K<sub>2</sub> + 4K<sub>3</sub> + 5K<sub>4</sub>     <sub> </sub>  &#x2265; 124
   	      1K<sub>1</sub> + 3K<sub>2</sub>     <sub> </sub> + 3K<sub>4</sub> + 6K<sub>5</sub>  &#x2265; 854 
   	      
   	 con K<sub>2</sub>, K<sub>5</sub> &#x2208; &#x2124; 
   	     K<sub>1</sub>, K<sub>4</sub> &#x2208; {0,1}
   	     1 &#x2264; K<sub>2</sub> &#x2264; +6
   	     1 &#x2264; K<sub>3</sub> &#x2264; +&infin;     
   	     con K<sub>1</sub>, K<sub>4</sub>, K<sub>5</sub> &#x2265; 0
</pre>
				<br> Questo problema presenta variabili intere e
				binarie, mentre la variabile K<sub>3</sub> non &egrave; soggetta a nessun 
				vincolo di interezza. Per dichiarare una variabile binaria basta
				aggiungere un rigo avente TYPE "binary" [rigo 22]. Se la i-esima variabile
				&egrave; binaria basta porre 1 nel corrispondente rigo dei binary.
				Si rammenta che una variabile non pu&ograve; essere definita
				contemporaneamente sia binaria che intera. Nel nostro caso le
				variabili K<sub>1</sub> e K<sub>4</sub> sono binarie mentre le
				variabili K<sub>2</sub> e K<sub>5</sub> sono intere.
			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">


import it.ssc.log.SscLogger;
import it.ssc.pl.milp.MILP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.ref.InputString;

public class Esempio {

	public static void main(String[] args) throws Exception {

		String milp_string=

						"3 1 4 7 8 min      . "  +"\n"+
						"5 2 0 3 0 le       9 "  +"\n"+
						"3 1 1 0 5 ge       12"  +"\n"+
						"6 3 4 5 0 ge       124" +"\n"+
						"1 3 0 3 6 ge       854" +"\n"+
						"0 1 1 0 0 lower    . "  +"\n"+
						". 6 . . . upper    . "  +"\n"+
						"0 1 0 0 1 integer  . "  +"\n"+
						"1 0 0 1 0 binary   . "  +"\n";  

		InputString milp_input = new InputString(milp_string);
		milp_input.setInputFormat("K1-K5:double, TYPE:varstring(20),  RHS:double");

		MILP milp=new MILP(milp_input);
		SolutionType solution_type= milp.resolve();

		if(solution_type==SolutionType.OPTIMUM) { 
			Solution solution=milp.getSolution();
			for(Variable var:solution.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
		}	
	}
}

				</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>





































			<h3 class="paragraph_title">
				<a id="ese2_5">Esempio 2.5</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di MILP dato da: <br> <br>
				<pre>
	 max  X<sub>1</sub> + 3.0X<sub>2</sub>
	 
	      X<sub>1</sub> +    X<sub>2</sub> &#x2265; 1
   	      X<sub>1</sub> + 1.4X<sub>2</sub> &#x2264; 6
   	    -5X<sub>1</sub> + 3.0X<sub>2</sub> &#x2264; 5
   	    
   	 con  X<sub>1</sub>, X<sub>2</sub> &#x2265; 0
   	      X<sub>1</sub> &#x2208; &#x2124; 
   	      X<sub>2</sub> &#x2208; {0,1}
</pre>
				<br> Vogliamo risolvere questo problema di programmazione
				lineare intera, che presenta anche variabili binarie, utilizzando 
				la notazione matriciale. 
				In questa notazione, per rappresentare le variabili binarie,
				basta aggiungere alla matrice A dei coefficienti un rigo 
				per dichiararle [rigo 15]. Con
				il valore 1 si dichiara la variabile binaria, con lo 0 la si
				considera non binaria. Va anche aggiunto il valore ConsType.BIN
				[rigo 20] per dichiarare che l'ultimo rigo della matrice A &egrave;
				relativo alla definizione delle variabili binarie.
			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">
import static it.ssc.pl.milp.LP.NaN;			
import it.ssc.log.SscLogger;
import it.ssc.pl.milp.*;
import java.util.ArrayList;

public class Esempio {
	
	public static void main(String[] args) throws Exception {

		double A[][]={ 
				{ 1.0 , 1.0 },
				{ 1.0 , 1.4 },
				{-5.0 , 3.0 }, 
				{ 1.0 , 0.0 },  //definizione degli integer
				{ 0.0 , 1.0 },  //definizione dei binary
				} ;
		double b[]= { 1.0, 6.0 ,5.0, NaN, NaN};
		double c[]= { 1.0, 3.0  };	

		ConsType[] rel= {ConsType.GE, ConsType.LE, ConsType.LE, ConsType.INT , ConsType.BIN};

		LinearObjectiveFunction f = new LinearObjectiveFunction(c, GoalType.MAX);

		ArrayList< Constraint > constraints = new ArrayList< Constraint >();
		for(int i=0; i < A.length; i++) {
			constraints.add(new Constraint(A[i], rel[i], b[i]));
		}

		MILP lp = new MILP(f,constraints); 
		SolutionType solution_type=lp.resolve();

		if(solution_type==SolutionType.OPTIMUM) { 
			Solution solution=lp.getSolution();
			for(Variable var:solution.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
		}	
	}
}
			</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>










































			<h3 class="paragraph_title">
				<a id="ese2_6">Esempio 2.6</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di MILP : <br> <br>
				<pre>
	 max  Y<sub>1</sub> + 3.0Y<sub>2</sub>
	 
	      Y<sub>1</sub> +    Y<sub>2</sub> &#x2265; 1
   	      Y<sub>1</sub> + 1.4Y<sub>2</sub> &#x2264; 6
   	    -5Y<sub>1</sub> + 3.0Y<sub>2</sub> &#x2264; 5
   	    
   	 con  Y<sub>1</sub> &#x2208; {0,1}  
   	      Y<sub>2</sub> &#x2208; &#x2124;
   	     -1 &#x2264; Y<sub>1</sub> &#x2264; +1
   	     -&infin; &#x2264; Y<sub>2</sub> &#x2264; +&infin;  
</pre>
				<br> Vogliamo risolvere questo problema di programmazione
				lineare misto intera, che  presenta  anche variabili  binarie, utilizzando la
				notazione sparsa. Per indicare che la variabile Y<sub>1</sub>
				&egrave; binaria basta aggiungere nella colonna dei ROW_ il
				marcatore che le definisce. Questo marcatore (da noi chiamato
				"var_bin" , ma che pu&ograve; avere qualsiasi altro nome) 
				deve avere associato un TYPE di tipo BINARY [rigo 24].<br>
				<br> Una volta definito il marcatore delle variabili binarie,
				basta dichiarare [rigo 32] che la variabile Y<sub>1</sub> &egrave;
				di tipo var_bin (ovvero BINARY) ponendo nella colonna dei COEF il
				valore 1.


			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">

import it.ssc.log.SscLogger;
import it.ssc.pl.milp.FormatTypeInput.FormatType;
import it.ssc.pl.milp.MILP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.ref.InputString;

public class Esempio {
	
	public static void main(String[] args) throws Exception {
	
		String lp_sparse = 
		
			//    TYPE   COL_   ROW_    COEF 
				 
				" MAX     .    costo      .    \n" +   
                " GE      .    row1       .    \n" +	  
                " LE      .    row2       .    \n" +  
                " LE      .    row3       .    \n" +
                " UPPER   .    lim_sup    .    \n" +
                " LOWER   .    lim_inf    .    \n" +    
                " INTEGER .    var_int    .    \n" + 
                " BINARY  .    var_bin    .    \n" + 
		
				" .      Y1    costo      1    \n" +
				" .      Y1    row1       1    \n" +	  
		        " .      Y1    row2       1    \n" +  
		        " .      Y1    row3      -5    \n" +
		        " .      Y1    lim_sup    1    \n" +
		        " .      Y1    lim_inf   -1    \n" +	
		        " .      Y1    var_bin    1    \n" +	
				 
				" .      Y2    costo      3    \n" +
				" .      Y2    row1       1    \n" +	  
		        " .      Y2    row2     1.4    \n" +  
		        " .      Y2    row3       3    \n" +
		        " .      Y2    lim_sup    .    \n" +
		        " .      Y2    lim_inf    .    \n" +	
		        " .      Y2    var_int    1    \n" +
		         
				" .     RHS    row1       1    \n" +	  
				" .     RHS    row2       6    \n" +  
				" .     RHS    row3       5    \n"   ;
			

		InputString lp_input = new InputString(lp_sparse); 
		lp_input.setInputFormat("TYPE:varstring(7), COL_:varstring(3) , ROW_:varstring(7), COEF:double"); 

		MILP milp = new MILP(lp_input,FormatType.SPARSE);  
		SolutionType solution_type=milp.resolve();
		
		if(solution_type==SolutionType.OPTIMUM) { 
			Solution solution=milp.getSolution();
			for(Variable var:solution.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
		}	
	}
}
				</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>





























	<h3 class="paragraph_title">
				<a id="ese2_7">Esempio 2.7</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di LP : <br> <br>
				<pre>
	
   	 min  3X<sub>1</sub> +  X<sub>2</sub> + 4X<sub>3</sub> + 7X<sub>4</sub> + 8X<sub>5</sub>
   	 
   	      5X<sub>1</sub> + 2X<sub>2</sub>     <sub> </sub> + 3X<sub>4</sub>     <sub> </sub>  &#x2265;    9
   	      3X<sub>1</sub> +  X<sub>2</sub> +  X<sub>3</sub>     <sub> </sub> + 5X<sub>5</sub>  &#x2265; 12.5
   	      6X<sub>1</sub> + 3X<sub>2</sub> + 4X<sub>3</sub> + 5X<sub>4</sub>     <sub> </sub>  &#x2264;  124
   	       X<sub>1</sub> + 3X<sub>2</sub>     <sub> </sub> + 3X<sub>4</sub> + 6X<sub>5</sub>  &#x2264;  854
   	      
   	 con X<sub>1</sub>, X<sub>2</sub>, X<sub>3</sub>, X<sub>4</sub>, X<sub>5</sub> &#x2265; 0
   	     X<sub>2</sub>, X<sub>3</sub> &#x2208; &#x2124;
   	        
				</pre>
				<br> Vogliamo risolvere questo problema di programmazione lineare 
				misto intera usando il formato di rappresentazione a 
				disequazioni. In questo formato per aggiungere il vincolo 
				di interezza sulle variabili  X<sub>2</sub> e X<sub>3</sub>  basta aggiungere 
				un rigo [rigo 16].  Nel caso in cui si vogliano definire variabili binare o semicontinue, la sintassi 
				&egrave; uguale a quella della dichiarazione degli interi, ovvero si antepone la parola chiave "bin" o "sec" e si 
				fa seguire una lista di variabili separate da virgola.  

			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">

import java.util.ArrayList;
import it.ssc.log.SscLogger;
import it.ssc.pl.milp.*;

public class Esempio {
	
	public static void main(String[] args) throws Exception {
		
		ArrayList< String > constraints = new ArrayList< String >();
		
		constraints.add("min:  3x1 +X2 +4x3 +7x4 +8X5 "); 
        constraints.add("5x1 +2x2 +3X4       >= 9");
        constraints.add("3x1 + X2 +X3 +5X5   >= 12.5");
        constraints.add("6X1+3.0x2 +4X3 +5X4 <= 124");
        constraints.add(" X1 + 3x2 +3X4 +6X5 <= 854");
        constraints.add(" int x2, X3 ");
			
		MILP milp = new MILP(constraints); 
		SolutionType solution_type=milp.resolve();
		
		if(solution_type==SolutionType.OPTIMUM) {
			Solution soluzione=milp.getSolution();
			for(Variable var:soluzione.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore :"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+soluzione.getOptimumValue());
		}
	}
}
			</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>


































			<h3 class="paragraph_title">
				<a id="ese2_8">Esempio 2.8</a>
			</h3>
			<div class="commento">
				
				<br> Si consideri il problema di programmazione 
				lineare intera riportato nella sezione sottostante. 
				In questo esempio 
				si confronta la soluzione ottima finale intera con quella 
				ottenuta dal suo rilassamento (i valori del problema rilassato sono riportati 
				tra parentesi quadre [righi 46-49]) 


			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">

import it.ssc.context.exception.InvalidSessionException;
import it.ssc.log.SscLogger;
import it.ssc.pl.milp.*;
import java.util.ArrayList;
import static it.ssc.pl.milp.LP.NaN;

public class Esempio {
	
	public static void main(String arg[]) throws InvalidSessionException, Exception {

		double[]   c =  { 2, 2, 2, 2, 2 ,2, 2, 2, 2, 2,2 ,2 ,2 };
		double[]   b =  {1000, 1234, 1000, 1000, 1000, 1000, 1000, 1000, 1000};
		
		double[][] A ={	{ 2., 9. ,7. ,5. ,9. ,6. ,3., 7., 8. ,7. ,5. ,3. ,1. },
						{ 4. ,1. ,2. ,3. ,6. ,4. ,5. ,2. ,8. ,5. ,3. ,4., 7. },
						{ 3. ,4. ,2. ,5. ,7. ,6. ,3. ,5. ,7. ,4. ,6. ,8. ,6. },
						{ 4. ,6. ,9. ,8. ,7. ,6. ,5. ,4. ,3. ,2. ,3. ,5. ,6. },
						{ 4. ,4. ,7. ,5. ,3. ,8. ,5. ,6. ,3. ,5. ,6. ,4. ,6. },
						{ 2. ,6. ,4. ,5. ,7. ,5. ,6. ,4. ,6. ,7. ,4. ,4. ,6. },
						{ 4. ,6. ,9. ,8. ,3. ,6. ,5. ,5. ,3. ,2. ,9. ,5. ,6. },
						{ 4. ,5. ,7. ,8. ,3. ,8. ,3. ,6. ,3. ,5. ,6. ,1. ,6. },
						{ 2., 2., 4., 3., 7. ,5. ,9. ,4. ,6. ,7. ,8. ,4., 6. }};

		double[] upper ={ 190.5, NaN, NaN, NaN, NaN ,NaN ,NaN ,NaN ,35.0 ,NaN ,NaN ,NaN, NaN };
		double[] integer ={ 1.0, 1.0, 1.0, 1.0, 1.0 ,1.0 ,1.0 ,1.0 ,1.0 ,1.0 ,1.0 ,1.0, 1.0 };

		LinearObjectiveFunction f = new LinearObjectiveFunction(c, GoalType.MAX);

		ArrayList< Constraint > constraints = new ArrayList< Constraint >();
		for(int i=0; i< A.length; i++) {
			constraints.add(new Constraint(A[i], ConsType.LE, b[i])); 
		}

		constraints.add(new Constraint(upper,   ConsType.UPPER, NaN)); 
		constraints.add(new Constraint(integer, ConsType.INT , NaN)); 

		MILP milp = new MILP(f,constraints);
		SolutionType solution=milp.resolve();

		if(solution==SolutionType.OPTIMUM) { 
			Solution sol=milp.getSolution();
			Solution sol_relax=milp.getRelaxedSolution();
			Variable[] var_int=sol.getVariables();
			Variable[] var_relax=sol_relax.getVariables();
			for(int _i=0; _i< var_int.length;_i++) {
				SscLogger.log("Nome variabile :"+var_int[_i].getName() + " valore:"+var_int[_i].getValue()+ 
						      " ["+var_relax[_i].getValue()+"]");
			}
			SscLogger.log("valore ottimo:"+sol.getOptimumValue() +" ["+sol_relax.getOptimumValue()+"]"); 
		}
	}
}
				</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>











































	<h3 class="paragraph_title">
				<a id="ese2_9">Esempio 2.9</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di MILP : <br> <br>
				<pre>
	
   	 min  3X<sub>1</sub> +  X<sub>2</sub> + 4X<sub>3</sub> + 7X<sub>4</sub> + 8X<sub>5</sub>
   	 
   	      5X<sub>1</sub> + 2X<sub>2</sub>     <sub> </sub> + 3X<sub>4</sub>     <sub> </sub>  &#x2265;    9
   	      3X<sub>1</sub> +  X<sub>2</sub> +  X<sub>3</sub>     <sub> </sub> + 5X<sub>5</sub>  &#x2265; 12.5
   	      6X<sub>1</sub> + 3X<sub>2</sub> + 4X<sub>3</sub> + 5X<sub>4</sub>     <sub> </sub>  &#x2264;  124
   	       X<sub>1</sub> + 3X<sub>2</sub>     <sub> </sub> + 3X<sub>4</sub> + 6X<sub>5</sub>  &#x2264;  854
   	      
   	 con X<sub>1</sub>, X<sub>2</sub>, X<sub>3</sub>, X<sub>4</sub>, X<sub>5</sub> &#x2265; 0
   	     X<sub>2</sub>, X<sub>3</sub> &#x2208; &#x2124;
   	        
				</pre>
				<br> Questo problema &egrave; identico al problema 2.7. Nel codice per la sua risoluzione sono state aggiunti 
				     dei righi per recuperare il valore che la parte LHS di ogni vincolo (la parte alla sinistra della relazione) 
				      assume valorizzando le variabili incognite con la soluzione ottima. Il valore LHS viene poi  
				      confrontato con il corrispettivo valore RHS. [righi 32-35]. Ai vincoli si pu&ograve; dare un nome, 
				      basta anteporre il nome al vincolo, facendolo seguire dai due punti (nome:vincolo). Occorre ricordare
				      che nel caso della definizione degli upper e lower bound le etichette non vanno assolutamente inserite 
				      (esempio 1.11).  

			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">
import java.util.ArrayList;
import it.ssc.log.SscLogger;
import it.ssc.pl.milp.*;


public class Esempio {

	public static void main(String[] args) throws Exception {

		
		ArrayList< String > constraints = new ArrayList< String >();
         
        constraints.add("min:  3x1 +X2 +4x3 +7x4 +8X5 "); 
        constraints.add("5x1 +2x2 +3X4       >= 9");
        constraints.add("3x1 + X2 +X3 +5X5   >= 12.5");
        constraints.add("6X1+3.0x2 +4X3 +5X4 <= 124");
        constraints.add(" X1 + 3x2 +3X4 +6X5 <= 854");
        constraints.add(" int x2, X3 ");
	
		MILP milp = new MILP(constraints); 
		SolutionType solution_type=milp.resolve();

		if(solution_type==SolutionType.OPTIMUM) {
			Solution soluzione=milp.getSolution();
			for(Variable var:soluzione.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore :"+var.getValue());
			}
			for(SolutionConstraint sol_constraint: soluzione.getSolutionConstraint()) {
				SscLogger.log("Vincolo "+sol_constraint.getName()+" : valore="+sol_constraint.getValue() + 
						      "[ "+sol_constraint.getRel()+"  "+sol_constraint.getRhs()+" ]" );
			}
			SscLogger.log("Valore ottimo:"+soluzione.getOptimumValue());
		}
	}
}

			</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>



















			<h3 class="paragraph_title">
				<a id="ese2_10">Esempio 2.10</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di programmazione  lineare misto intera
				(MILP) che presenta anche una variabile semicontinua: <br> <br>
				<pre>
	
   	 min  3K<sub>1</sub> +  K<sub>2</sub> + 4K<sub>3</sub> + 7K<sub>4</sub> + 8K<sub>5</sub>
   	 
   	      5K<sub>1</sub> + 2K<sub>2</sub>     <sub> </sub> + 3K<sub>4</sub>     <sub> </sub>  &#x2264;   9
   	      3K<sub>1</sub> +  K<sub>2</sub> +  K<sub>3</sub>     <sub> </sub> + 5K<sub>5</sub>  &#x2265;  12
   	      6K<sub>1</sub> + 3K<sub>2</sub> + 4K<sub>3</sub> + 5K<sub>4</sub>     <sub> </sub>  &#x2265; 124
   	      1K<sub>1</sub> + 3K<sub>2</sub>     <sub> </sub> + 3K<sub>4</sub> + 6K<sub>5</sub>  &#x2265; 854 
   	      
   	 con K<sub>2</sub>, K<sub>5</sub> &#x2208; &#x2124; 
   	     K<sub>1</sub>, K<sub>4</sub> &#x2208; {0,1}
   	     <b>1 &#x2264; K<sub>2</sub> &#x2264; 6 oppure K<sub>2</sub> =0</b>
   	     1 &#x2264; K<sub>3</sub> &#x2264; +&infin;     
   	     con K<sub>1</sub>, K<sub>4</sub>, K<sub>5</sub> &#x2265; 0
</pre>
				<br> Questo problema  &egrave; identico al problema 2.4 con l'aggiunta della 
				condizione che la variabile K<sub>2</sub> &egrave; semicontinua, ovvero essa non &egrave; strettamente vincolata 
				ad essere compresa tra i valori di upper e lower, ma pu&ograve; anche assumere il valore 0. 
			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">


import it.ssc.log.SscLogger;
import it.ssc.pl.milp.MILP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.ref.InputString;

public class Esempio {

	public static void main(String[] args) throws Exception {

		String milp_string=

						"3 1 4 7 8 min      . "  +"\n"+
						"5 2 0 3 0 le       9 "  +"\n"+
						"3 1 1 0 5 ge       12"  +"\n"+
						"6 3 4 5 0 ge       124" +"\n"+
						"1 3 0 3 6 ge       854" +"\n"+
						"0 1 1 0 0 lower    . "  +"\n"+
						". 6 . . . upper    . "  +"\n"+
						"0 1 0 0 1 integer  . "  +"\n"+
						"1 0 0 1 0 binary   . "  +"\n"+
                        "0 1 0 0 0 semicont . "  +"\n"; 

		InputString milp_input = new InputString(milp_string);
		milp_input.setInputFormat("K1-K5:double, TYPE:varstring(20),  RHS:double");

		MILP milp=new MILP(milp_input);
		SolutionType solution_type= milp.resolve();

		if(solution_type==SolutionType.OPTIMUM) { 
			Solution solution=milp.getSolution();
			for(Variable var:solution.getVariables()) {
				SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
			}
			SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
		}	
	}
}

				</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>





























			<h3 class="paragraph_title">
				<a id="ese2_11">Esempio 2.11</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di MILP dato da: <br> <br>
				<pre>
	 max  -X<sub>1</sub> + 3.0X<sub>2</sub>
	 
	      X<sub>1</sub> +    X<sub>2</sub> &#x2265; 1
   	      X<sub>1</sub> + 1.4X<sub>2</sub> &#x2264; 6
   	    -5X<sub>1</sub> + 3.0X<sub>2</sub> &#x2264; 5
   	    
   	 con  X<sub>1</sub>, X<sub>2</sub> &#x2265; 0
   	      X<sub>1</sub> &#x2208; &#x2124; 
   	      X<sub>2</sub> &#x2208; {0,1}
   	      <b>1 &#x2264; X<sub>1</sub> &#x2264; 3 oppure X<sub>1</sub> =0</b>
</pre>
				<br> Vogliamo risolvere questo problema di programmazione
				lineare intera, che presenta anche una variabile semicontinua intera, utilizzando 
				la notazione matriciale. 
				
			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">
				
import static it.ssc.pl.milp.LP.NaN;
import it.ssc.log.SscLogger;
import it.ssc.pl.milp.*;
import java.util.ArrayList;
 
public class Esempio {
     
    public static void main(String[] args) throws Exception {
 
        double A[][]={ 
                { 1.0 , 1.0 },
                { 1.0 , 1.4 },
                {-5.0 , 3.0 }, 
                { 1.0 , 0.0 },  //definizione degli integer
                { 0.0 , 1.0 },  //definizione dei binary
                { 1.0 , 0.0 },  //definizione dei semicontinuous
                { 3.0 , NaN},   //definizione dei upper
                { 1.0 , 0.0 },  //definizione dei lower
                } ;
        double b[]= { 1.0, 6.0 ,5.0, NaN, NaN, NaN, NaN, NaN};
        double c[]= { -1.0, 3.0  };  
 
        ConsType[] rel= {ConsType.GE, ConsType.LE, ConsType.LE, ConsType.INT, ConsType.BIN,
        		         ConsType.SEMICONT, ConsType.UPPER, ConsType.LOWER};
 
        LinearObjectiveFunction f = new LinearObjectiveFunction(c, GoalType.MAX);
 
        ArrayList< Constraint > constraints = new ArrayList< Constraint >();
        for(int i=0; i < A.length; i++) {
            constraints.add(new Constraint(A[i], rel[i], b[i]));
        }
 
        MILP lp = new MILP(f,constraints); 
        SolutionType solution_type=lp.resolve();
 
        if(solution_type==SolutionType.OPTIMUM) { 
            Solution solution=lp.getSolution();
            for(Variable var:solution.getVariables()) {
                SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
            }
            SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
        }   
    }
}


			</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>





























			<h3 class="paragraph_title">
				<a id="ese2_12">Esempio 2.12</a>
			</h3>
			<div class="commento">
				Si consideri il seguente problema di MILP : <br> <br>
				<pre>
	 max  Y<sub>1</sub> - 3.0Y<sub>2</sub>
	 
	      Y<sub>1</sub> +    Y<sub>2</sub> &#x2265; 1
   	      Y<sub>1</sub> + 1.4Y<sub>2</sub> &#x2264; 6
   	    -5Y<sub>1</sub> + 3.0Y<sub>2</sub> &#x2264; 5
   	    
   	 con  Y<sub>1</sub> &#x2208; {0,1}  
   	      Y<sub>2</sub> &#x2208; &#x2124;
   	     -1 &#x2264; Y<sub>1</sub> &#x2264; +1
   	      <b>1 &#x2264; Y<sub>2</sub> &#x2264; +&infin;  oppure Y<sub>2</sub> = 0</b>
</pre>
				<br> Vogliamo risolvere questo problema di programmazione
				lineare misto intera, che  presenta  anche variabili  semicontinue, utilizzando la
				notazione sparsa. 


			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">


import it.ssc.log.SscLogger;
import it.ssc.pl.milp.FormatTypeInput.FormatType;
import it.ssc.pl.milp.MILP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.ref.InputString;
 
public class Esempio {
     
    public static void main(String[] args) throws Exception {
     
        String lp_sparse = 
         
            //    TYPE   COL_   ROW_    COEF 
                  
                " MAX     .    costo      .    \n" +   
                " GE      .    row1       .    \n" +      
                " LE      .    row2       .    \n" +  
                " LE      .    row3       .    \n" +
                " UPPER   .    lim_sup    .    \n" +
                " LOWER   .    lim_inf    .    \n" +    
                " INTEGER .    var_int    .    \n" + 
                " BINARY  .    var_bin    .    \n" + 
                " SEMICONT .   var_sc     .    \n" + 
         
                " .      Y1    costo      1    \n" +
                " .      Y1    row1       1    \n" +      
                " .      Y1    row2       1    \n" +  
                " .      Y1    row3      -5    \n" +
                " .      Y1    lim_sup    1    \n" +
                " .      Y1    lim_inf   -1    \n" +    
                " .      Y1    var_bin    1    \n" +    
                  
                " .      Y2    costo     -3    \n" +
                " .      Y2    row1       1    \n" +      
                " .      Y2    row2     1.4    \n" +  
                " .      Y2    row3       3    \n" +
                " .      Y2    lim_sup    .    \n" +
                " .      Y2    lim_inf    1    \n" +    
                " .      Y2    var_int    1    \n" +
                " .      Y2    var_sc     1    \n" +
                  
                " .     RHS    row1       1    \n" +      
                " .     RHS    row2       6    \n" +  
                " .     RHS    row3       5    \n"   ;
             
 
        InputString lp_input = new InputString(lp_sparse); 
        lp_input.setInputFormat("TYPE:varstring(8), COL_:varstring(3) , ROW_:varstring(7), COEF:double"); 
 
        MILP milp = new MILP(lp_input,FormatType.SPARSE);  
        SolutionType solution_type=milp.resolve();
         
        if(solution_type==SolutionType.OPTIMUM) { 
            Solution solution=milp.getSolution();
            for(Variable var:solution.getVariables()) {
                SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
            }
            SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
        }   
    }
}

				</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>
































<h3 class="paragraph_title">
				<a id="ese2_13">Esempio 2.13</a>
			</h3>
			<div class="commento">
				
				<br> Si consideri il problema di programmazione 
				lineare intera riportato nella sezione sottostante . 
				Vogliamo risolvere questo problema utilizzando un'implementazione del B&B parallelo.  
				Per far questo basta aggiugere l'istruzione al rigo [39], con il quale si dichiara il numero 
				di thread (in questo caso 4) da utilizzare per eseguire un B&B parallelo. 


			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">


import it.ssc.context.exception.InvalidSessionException;
import it.ssc.log.SscLogger;
import it.ssc.pl.milp.*;
import it.ssc.pl.milp.util.MILPThreadsNumber;
import static it.ssc.pl.milp.LP.NaN; 
import java.util.ArrayList;
 
 
public class Esempio {
     
    public static void main(String arg[]) throws InvalidSessionException, Exception {
 
        double[]   c =  { 2, 2, 2, 2, 2 , 2, 2, 2, 2, 2, 2 ,2 , 2 };
        double[]   b =  {1000, 1234, 1000, 1000, 1000, 1000, 1000, 1000, 1000};
         
        double[][] A ={ { 2., 9. ,7. ,5. ,9. ,6. ,3., 7., 8. ,7. ,5. ,3. ,1. },
                        { 4. ,1. ,2. ,3. ,6. ,4. ,5. ,2. ,8. ,5. ,3. ,4., 7. },
                        { 3. ,4. ,2. ,5. ,7. ,6. ,3. ,5. ,7. ,4. ,6. ,8. ,6. },
                        { 4. ,6. ,9. ,8. ,7. ,6. ,5. ,4. ,3. ,2. ,3. ,5. ,6. },
                        { 4. ,4. ,7. ,5. ,3. ,8. ,5. ,6. ,3. ,5. ,6. ,4. ,6. },
                        { 2. ,6. ,4. ,5. ,7. ,5. ,6. ,4. ,6. ,7. ,4. ,4. ,6. },
                        { 4. ,6. ,9. ,8. ,3. ,6. ,5. ,5. ,3. ,2. ,9. ,5. ,6. },
                        { 4. ,5. ,7. ,8. ,3. ,8. ,3. ,6. ,3. ,5. ,6. ,1. ,6. },
                        { 2., 2., 4., 3., 7. ,5. ,9. ,4. ,6. ,7. ,8. ,4., 6. }};
 
         
        double[] integer ={ 1.0, 1.0, 1.0, 1.0, 1.0 ,1.0 ,1.0 ,1.0 ,1.0 ,1.0 ,1.0 ,1.0, 1.0 };
 
        LinearObjectiveFunction f = new LinearObjectiveFunction(c, GoalType.MAX);
 
        ArrayList< Constraint > constraints = new ArrayList< Constraint >();
        for(int i=0; i< A.length; i++) {
            constraints.add(new Constraint(A[i], ConsType.LE, b[i])); 
        }
 
        constraints.add(new Constraint(integer, ConsType.INT , NaN)); 
 
        MILP milp = new MILP(f,constraints);
        milp.setThreadNumber(MILPThreadsNumber.N_4);
        SolutionType solutionType=milp.resolve();
 
        if(solutionType==SolutionType.OPTIMUM) { 
            Solution solution=milp.getSolution();
            for(Variable var:solution.getVariables()) {
                SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
            }
            SscLogger.log("Valore ottimo:"+solution.getOptimumValue());
        }  
    }
}

				</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>











































<h3 class="paragraph_title">
				<a id="ese2_14">Esempio 2.14</a>
			</h3>
			<div class="commento">
				
				
				<br> Se l'esigenza  &egrave; quella di ottenere una soluzione
				ammissibile non necessariamente ottima , basta invocare il metodo
				setJustTakeFeasibleSolution() passandogli il valore "true" (rigo 24). Questa opzione
				permette di far eseguire il B&B im modo di ottenere una  soluzione 
				ammissibile . In questo caso il valore restituito da  resolve() (se esiste una soluzione ammissibile)
				sar&agrave; SolutionType.FEASIBLE. Nel nostro esempio la soluzione ammissibile intera ottenuta (X<sub>1</sub>=2,X<sub>2</sub>=2)
				ha come valore sulla f.o. -6 , mentre la soluzione ottima (X<sub>1</sub>=3,X<sub>2</sub>=1) ha come valore -7. 


			</div>
			<br> <br>

			<div class="codice_example">
				<pre class="brush: java;">


import it.ssc.log.SscLogger;
import it.ssc.pl.milp.MILP;
import it.ssc.pl.milp.Solution;
import it.ssc.pl.milp.SolutionType;
import it.ssc.pl.milp.Variable;
import it.ssc.ref.InputString;
 
public class Esempio2_bix {
    public static void main(String[] args) throws Exception {
 
        String milp_string=
                 
                        "-2 -1   min        ."   +"\n"+
                        "-1 -1   ge        -5"   +"\n"+
                        "1  -1   ge         0"   +"\n"+
                        "-6 -2   ge       -21"   +"\n"+
                        "4   3  upper       ."   +"\n"+
                        "1   1  integer     ."   +"\n" ;  
 
        InputString milp_input = new InputString(milp_string);
        milp_input.setInputFormat("X1-X2:double, TYPE:varstring(20),  RHS:double");
 
        MILP milp=new MILP(milp_input);
        milp.setJustTakeFeasibleSolution(true);
        SolutionType solution_type= milp.resolve();
 
        if(solution_type==SolutionType.FEASIBLE) { 
            Solution solution=milp.getSolution();
            for(Variable var:solution.getVariables()) {
                SscLogger.log("Nome variabile :"+var.getName() + " valore:"+var.getValue());
            }
            SscLogger.log("Valore soluzione sulla f.o.:"+solution.getOptimumValue());
        }   
    }
}
				</pre>
			</div>
<div class="commento">
<br>
<a title="Torna all'indice" href="#home_indice"><img alt="Torna all'indice" src="images/up.png" /></a>
</div>















		</div>
	</div>
</body>